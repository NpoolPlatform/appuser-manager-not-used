// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"

	"github.com/NpoolPlatform/appuser-manager/pkg/db/ent/app"
	"github.com/NpoolPlatform/appuser-manager/pkg/db/ent/appcontrol"
	"github.com/NpoolPlatform/appuser-manager/pkg/db/ent/approle"
	"github.com/NpoolPlatform/appuser-manager/pkg/db/ent/approleuser"
	"github.com/NpoolPlatform/appuser-manager/pkg/db/ent/appuser"
	"github.com/NpoolPlatform/appuser-manager/pkg/db/ent/appusercontrol"
	"github.com/NpoolPlatform/appuser-manager/pkg/db/ent/appuserextra"
	"github.com/NpoolPlatform/appuser-manager/pkg/db/ent/appusersecret"
	"github.com/NpoolPlatform/appuser-manager/pkg/db/ent/appuserthirdparty"
	"github.com/NpoolPlatform/appuser-manager/pkg/db/ent/auth"
	"github.com/NpoolPlatform/appuser-manager/pkg/db/ent/authhistory"
	"github.com/NpoolPlatform/appuser-manager/pkg/db/ent/banapp"
	"github.com/NpoolPlatform/appuser-manager/pkg/db/ent/banappuser"
	"github.com/NpoolPlatform/appuser-manager/pkg/db/ent/kyc"
	"github.com/NpoolPlatform/appuser-manager/pkg/db/ent/loginhistory"
	"github.com/NpoolPlatform/appuser-manager/pkg/db/ent/predicate"
	"github.com/google/uuid"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeApp               = "App"
	TypeAppControl        = "AppControl"
	TypeAppRole           = "AppRole"
	TypeAppRoleUser       = "AppRoleUser"
	TypeAppUser           = "AppUser"
	TypeAppUserControl    = "AppUserControl"
	TypeAppUserExtra      = "AppUserExtra"
	TypeAppUserSecret     = "AppUserSecret"
	TypeAppUserThirdParty = "AppUserThirdParty"
	TypeAuth              = "Auth"
	TypeAuthHistory       = "AuthHistory"
	TypeBanApp            = "BanApp"
	TypeBanAppUser        = "BanAppUser"
	TypeKyc               = "Kyc"
	TypeLoginHistory      = "LoginHistory"
)

// AppMutation represents an operation that mutates the App nodes in the graph.
type AppMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	created_by    *uuid.UUID
	name          *string
	logo          *string
	description   *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*App, error)
	predicates    []predicate.App
}

var _ ent.Mutation = (*AppMutation)(nil)

// appOption allows management of the mutation configuration using functional options.
type appOption func(*AppMutation)

// newAppMutation creates new mutation for the App entity.
func newAppMutation(c config, op Op, opts ...appOption) *AppMutation {
	m := &AppMutation{
		config:        c,
		op:            op,
		typ:           TypeApp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppID sets the ID field of the mutation.
func withAppID(id uuid.UUID) appOption {
	return func(m *AppMutation) {
		var (
			err   error
			once  sync.Once
			value *App
		)
		m.oldValue = func(ctx context.Context) (*App, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().App.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApp sets the old App of the mutation.
func withApp(node *App) appOption {
	return func(m *AppMutation) {
		m.oldValue = func(context.Context) (*App, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of App entities.
func (m *AppMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().App.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *AppMutation) SetCreatedBy(u uuid.UUID) {
	m.created_by = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AppMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *AppMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[app.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *AppMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[app.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AppMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, app.FieldCreatedBy)
}

// SetName sets the "name" field.
func (m *AppMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AppMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *AppMutation) ClearName() {
	m.name = nil
	m.clearedFields[app.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *AppMutation) NameCleared() bool {
	_, ok := m.clearedFields[app.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *AppMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, app.FieldName)
}

// SetLogo sets the "logo" field.
func (m *AppMutation) SetLogo(s string) {
	m.logo = &s
}

// Logo returns the value of the "logo" field in the mutation.
func (m *AppMutation) Logo() (r string, exists bool) {
	v := m.logo
	if v == nil {
		return
	}
	return *v, true
}

// OldLogo returns the old "logo" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldLogo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogo: %w", err)
	}
	return oldValue.Logo, nil
}

// ClearLogo clears the value of the "logo" field.
func (m *AppMutation) ClearLogo() {
	m.logo = nil
	m.clearedFields[app.FieldLogo] = struct{}{}
}

// LogoCleared returns if the "logo" field was cleared in this mutation.
func (m *AppMutation) LogoCleared() bool {
	_, ok := m.clearedFields[app.FieldLogo]
	return ok
}

// ResetLogo resets all changes to the "logo" field.
func (m *AppMutation) ResetLogo() {
	m.logo = nil
	delete(m.clearedFields, app.FieldLogo)
}

// SetDescription sets the "description" field.
func (m *AppMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AppMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AppMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[app.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AppMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[app.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AppMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, app.FieldDescription)
}

// Where appends a list predicates to the AppMutation builder.
func (m *AppMutation) Where(ps ...predicate.App) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AppMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (App).
func (m *AppMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, app.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, app.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, app.FieldDeletedAt)
	}
	if m.created_by != nil {
		fields = append(fields, app.FieldCreatedBy)
	}
	if m.name != nil {
		fields = append(fields, app.FieldName)
	}
	if m.logo != nil {
		fields = append(fields, app.FieldLogo)
	}
	if m.description != nil {
		fields = append(fields, app.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case app.FieldCreatedAt:
		return m.CreatedAt()
	case app.FieldUpdatedAt:
		return m.UpdatedAt()
	case app.FieldDeletedAt:
		return m.DeletedAt()
	case app.FieldCreatedBy:
		return m.CreatedBy()
	case app.FieldName:
		return m.Name()
	case app.FieldLogo:
		return m.Logo()
	case app.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case app.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case app.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case app.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case app.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case app.FieldName:
		return m.OldName(ctx)
	case app.FieldLogo:
		return m.OldLogo(ctx)
	case app.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown App field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMutation) SetField(name string, value ent.Value) error {
	switch name {
	case app.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case app.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case app.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case app.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case app.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case app.FieldLogo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogo(v)
		return nil
	case app.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, app.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, app.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, app.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case app.FieldCreatedAt:
		return m.AddedCreatedAt()
	case app.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case app.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMutation) AddField(name string, value ent.Value) error {
	switch name {
	case app.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case app.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case app.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown App numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(app.FieldCreatedBy) {
		fields = append(fields, app.FieldCreatedBy)
	}
	if m.FieldCleared(app.FieldName) {
		fields = append(fields, app.FieldName)
	}
	if m.FieldCleared(app.FieldLogo) {
		fields = append(fields, app.FieldLogo)
	}
	if m.FieldCleared(app.FieldDescription) {
		fields = append(fields, app.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppMutation) ClearField(name string) error {
	switch name {
	case app.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case app.FieldName:
		m.ClearName()
		return nil
	case app.FieldLogo:
		m.ClearLogo()
		return nil
	case app.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown App nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppMutation) ResetField(name string) error {
	switch name {
	case app.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case app.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case app.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case app.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case app.FieldName:
		m.ResetName()
		return nil
	case app.FieldLogo:
		m.ResetLogo()
		return nil
	case app.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown App unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown App edge %s", name)
}

// AppControlMutation represents an operation that mutates the AppControl nodes in the graph.
type AppControlMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	created_at            *uint32
	addcreated_at         *int32
	updated_at            *uint32
	addupdated_at         *int32
	deleted_at            *uint32
	adddeleted_at         *int32
	app_id                *uuid.UUID
	signup_methods        *[]string
	extern_signin_methods *[]string
	recaptcha_method      *string
	kyc_enable            *bool
	signin_verify_enable  *bool
	invitation_code_must  *bool
	clearedFields         map[string]struct{}
	done                  bool
	oldValue              func(context.Context) (*AppControl, error)
	predicates            []predicate.AppControl
}

var _ ent.Mutation = (*AppControlMutation)(nil)

// appcontrolOption allows management of the mutation configuration using functional options.
type appcontrolOption func(*AppControlMutation)

// newAppControlMutation creates new mutation for the AppControl entity.
func newAppControlMutation(c config, op Op, opts ...appcontrolOption) *AppControlMutation {
	m := &AppControlMutation{
		config:        c,
		op:            op,
		typ:           TypeAppControl,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppControlID sets the ID field of the mutation.
func withAppControlID(id uuid.UUID) appcontrolOption {
	return func(m *AppControlMutation) {
		var (
			err   error
			once  sync.Once
			value *AppControl
		)
		m.oldValue = func(ctx context.Context) (*AppControl, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppControl.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppControl sets the old AppControl of the mutation.
func withAppControl(node *AppControl) appcontrolOption {
	return func(m *AppControlMutation) {
		m.oldValue = func(context.Context) (*AppControl, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppControlMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppControlMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppControl entities.
func (m *AppControlMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppControlMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppControlMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppControl.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppControlMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppControlMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppControl entity.
// If the AppControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppControlMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppControlMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppControlMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppControlMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppControlMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppControlMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppControl entity.
// If the AppControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppControlMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppControlMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppControlMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppControlMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppControlMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppControlMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppControl entity.
// If the AppControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppControlMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppControlMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppControlMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppControlMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *AppControlMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppControlMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppControl entity.
// If the AppControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppControlMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *AppControlMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[appcontrol.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *AppControlMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[appcontrol.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppControlMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, appcontrol.FieldAppID)
}

// SetSignupMethods sets the "signup_methods" field.
func (m *AppControlMutation) SetSignupMethods(s []string) {
	m.signup_methods = &s
}

// SignupMethods returns the value of the "signup_methods" field in the mutation.
func (m *AppControlMutation) SignupMethods() (r []string, exists bool) {
	v := m.signup_methods
	if v == nil {
		return
	}
	return *v, true
}

// OldSignupMethods returns the old "signup_methods" field's value of the AppControl entity.
// If the AppControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppControlMutation) OldSignupMethods(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignupMethods is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignupMethods requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignupMethods: %w", err)
	}
	return oldValue.SignupMethods, nil
}

// ClearSignupMethods clears the value of the "signup_methods" field.
func (m *AppControlMutation) ClearSignupMethods() {
	m.signup_methods = nil
	m.clearedFields[appcontrol.FieldSignupMethods] = struct{}{}
}

// SignupMethodsCleared returns if the "signup_methods" field was cleared in this mutation.
func (m *AppControlMutation) SignupMethodsCleared() bool {
	_, ok := m.clearedFields[appcontrol.FieldSignupMethods]
	return ok
}

// ResetSignupMethods resets all changes to the "signup_methods" field.
func (m *AppControlMutation) ResetSignupMethods() {
	m.signup_methods = nil
	delete(m.clearedFields, appcontrol.FieldSignupMethods)
}

// SetExternSigninMethods sets the "extern_signin_methods" field.
func (m *AppControlMutation) SetExternSigninMethods(s []string) {
	m.extern_signin_methods = &s
}

// ExternSigninMethods returns the value of the "extern_signin_methods" field in the mutation.
func (m *AppControlMutation) ExternSigninMethods() (r []string, exists bool) {
	v := m.extern_signin_methods
	if v == nil {
		return
	}
	return *v, true
}

// OldExternSigninMethods returns the old "extern_signin_methods" field's value of the AppControl entity.
// If the AppControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppControlMutation) OldExternSigninMethods(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternSigninMethods is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternSigninMethods requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternSigninMethods: %w", err)
	}
	return oldValue.ExternSigninMethods, nil
}

// ClearExternSigninMethods clears the value of the "extern_signin_methods" field.
func (m *AppControlMutation) ClearExternSigninMethods() {
	m.extern_signin_methods = nil
	m.clearedFields[appcontrol.FieldExternSigninMethods] = struct{}{}
}

// ExternSigninMethodsCleared returns if the "extern_signin_methods" field was cleared in this mutation.
func (m *AppControlMutation) ExternSigninMethodsCleared() bool {
	_, ok := m.clearedFields[appcontrol.FieldExternSigninMethods]
	return ok
}

// ResetExternSigninMethods resets all changes to the "extern_signin_methods" field.
func (m *AppControlMutation) ResetExternSigninMethods() {
	m.extern_signin_methods = nil
	delete(m.clearedFields, appcontrol.FieldExternSigninMethods)
}

// SetRecaptchaMethod sets the "recaptcha_method" field.
func (m *AppControlMutation) SetRecaptchaMethod(s string) {
	m.recaptcha_method = &s
}

// RecaptchaMethod returns the value of the "recaptcha_method" field in the mutation.
func (m *AppControlMutation) RecaptchaMethod() (r string, exists bool) {
	v := m.recaptcha_method
	if v == nil {
		return
	}
	return *v, true
}

// OldRecaptchaMethod returns the old "recaptcha_method" field's value of the AppControl entity.
// If the AppControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppControlMutation) OldRecaptchaMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecaptchaMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecaptchaMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecaptchaMethod: %w", err)
	}
	return oldValue.RecaptchaMethod, nil
}

// ClearRecaptchaMethod clears the value of the "recaptcha_method" field.
func (m *AppControlMutation) ClearRecaptchaMethod() {
	m.recaptcha_method = nil
	m.clearedFields[appcontrol.FieldRecaptchaMethod] = struct{}{}
}

// RecaptchaMethodCleared returns if the "recaptcha_method" field was cleared in this mutation.
func (m *AppControlMutation) RecaptchaMethodCleared() bool {
	_, ok := m.clearedFields[appcontrol.FieldRecaptchaMethod]
	return ok
}

// ResetRecaptchaMethod resets all changes to the "recaptcha_method" field.
func (m *AppControlMutation) ResetRecaptchaMethod() {
	m.recaptcha_method = nil
	delete(m.clearedFields, appcontrol.FieldRecaptchaMethod)
}

// SetKycEnable sets the "kyc_enable" field.
func (m *AppControlMutation) SetKycEnable(b bool) {
	m.kyc_enable = &b
}

// KycEnable returns the value of the "kyc_enable" field in the mutation.
func (m *AppControlMutation) KycEnable() (r bool, exists bool) {
	v := m.kyc_enable
	if v == nil {
		return
	}
	return *v, true
}

// OldKycEnable returns the old "kyc_enable" field's value of the AppControl entity.
// If the AppControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppControlMutation) OldKycEnable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKycEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKycEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKycEnable: %w", err)
	}
	return oldValue.KycEnable, nil
}

// ClearKycEnable clears the value of the "kyc_enable" field.
func (m *AppControlMutation) ClearKycEnable() {
	m.kyc_enable = nil
	m.clearedFields[appcontrol.FieldKycEnable] = struct{}{}
}

// KycEnableCleared returns if the "kyc_enable" field was cleared in this mutation.
func (m *AppControlMutation) KycEnableCleared() bool {
	_, ok := m.clearedFields[appcontrol.FieldKycEnable]
	return ok
}

// ResetKycEnable resets all changes to the "kyc_enable" field.
func (m *AppControlMutation) ResetKycEnable() {
	m.kyc_enable = nil
	delete(m.clearedFields, appcontrol.FieldKycEnable)
}

// SetSigninVerifyEnable sets the "signin_verify_enable" field.
func (m *AppControlMutation) SetSigninVerifyEnable(b bool) {
	m.signin_verify_enable = &b
}

// SigninVerifyEnable returns the value of the "signin_verify_enable" field in the mutation.
func (m *AppControlMutation) SigninVerifyEnable() (r bool, exists bool) {
	v := m.signin_verify_enable
	if v == nil {
		return
	}
	return *v, true
}

// OldSigninVerifyEnable returns the old "signin_verify_enable" field's value of the AppControl entity.
// If the AppControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppControlMutation) OldSigninVerifyEnable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSigninVerifyEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSigninVerifyEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSigninVerifyEnable: %w", err)
	}
	return oldValue.SigninVerifyEnable, nil
}

// ClearSigninVerifyEnable clears the value of the "signin_verify_enable" field.
func (m *AppControlMutation) ClearSigninVerifyEnable() {
	m.signin_verify_enable = nil
	m.clearedFields[appcontrol.FieldSigninVerifyEnable] = struct{}{}
}

// SigninVerifyEnableCleared returns if the "signin_verify_enable" field was cleared in this mutation.
func (m *AppControlMutation) SigninVerifyEnableCleared() bool {
	_, ok := m.clearedFields[appcontrol.FieldSigninVerifyEnable]
	return ok
}

// ResetSigninVerifyEnable resets all changes to the "signin_verify_enable" field.
func (m *AppControlMutation) ResetSigninVerifyEnable() {
	m.signin_verify_enable = nil
	delete(m.clearedFields, appcontrol.FieldSigninVerifyEnable)
}

// SetInvitationCodeMust sets the "invitation_code_must" field.
func (m *AppControlMutation) SetInvitationCodeMust(b bool) {
	m.invitation_code_must = &b
}

// InvitationCodeMust returns the value of the "invitation_code_must" field in the mutation.
func (m *AppControlMutation) InvitationCodeMust() (r bool, exists bool) {
	v := m.invitation_code_must
	if v == nil {
		return
	}
	return *v, true
}

// OldInvitationCodeMust returns the old "invitation_code_must" field's value of the AppControl entity.
// If the AppControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppControlMutation) OldInvitationCodeMust(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvitationCodeMust is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvitationCodeMust requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvitationCodeMust: %w", err)
	}
	return oldValue.InvitationCodeMust, nil
}

// ClearInvitationCodeMust clears the value of the "invitation_code_must" field.
func (m *AppControlMutation) ClearInvitationCodeMust() {
	m.invitation_code_must = nil
	m.clearedFields[appcontrol.FieldInvitationCodeMust] = struct{}{}
}

// InvitationCodeMustCleared returns if the "invitation_code_must" field was cleared in this mutation.
func (m *AppControlMutation) InvitationCodeMustCleared() bool {
	_, ok := m.clearedFields[appcontrol.FieldInvitationCodeMust]
	return ok
}

// ResetInvitationCodeMust resets all changes to the "invitation_code_must" field.
func (m *AppControlMutation) ResetInvitationCodeMust() {
	m.invitation_code_must = nil
	delete(m.clearedFields, appcontrol.FieldInvitationCodeMust)
}

// Where appends a list predicates to the AppControlMutation builder.
func (m *AppControlMutation) Where(ps ...predicate.AppControl) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AppControlMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AppControl).
func (m *AppControlMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppControlMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, appcontrol.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appcontrol.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appcontrol.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, appcontrol.FieldAppID)
	}
	if m.signup_methods != nil {
		fields = append(fields, appcontrol.FieldSignupMethods)
	}
	if m.extern_signin_methods != nil {
		fields = append(fields, appcontrol.FieldExternSigninMethods)
	}
	if m.recaptcha_method != nil {
		fields = append(fields, appcontrol.FieldRecaptchaMethod)
	}
	if m.kyc_enable != nil {
		fields = append(fields, appcontrol.FieldKycEnable)
	}
	if m.signin_verify_enable != nil {
		fields = append(fields, appcontrol.FieldSigninVerifyEnable)
	}
	if m.invitation_code_must != nil {
		fields = append(fields, appcontrol.FieldInvitationCodeMust)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppControlMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appcontrol.FieldCreatedAt:
		return m.CreatedAt()
	case appcontrol.FieldUpdatedAt:
		return m.UpdatedAt()
	case appcontrol.FieldDeletedAt:
		return m.DeletedAt()
	case appcontrol.FieldAppID:
		return m.AppID()
	case appcontrol.FieldSignupMethods:
		return m.SignupMethods()
	case appcontrol.FieldExternSigninMethods:
		return m.ExternSigninMethods()
	case appcontrol.FieldRecaptchaMethod:
		return m.RecaptchaMethod()
	case appcontrol.FieldKycEnable:
		return m.KycEnable()
	case appcontrol.FieldSigninVerifyEnable:
		return m.SigninVerifyEnable()
	case appcontrol.FieldInvitationCodeMust:
		return m.InvitationCodeMust()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppControlMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appcontrol.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appcontrol.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appcontrol.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appcontrol.FieldAppID:
		return m.OldAppID(ctx)
	case appcontrol.FieldSignupMethods:
		return m.OldSignupMethods(ctx)
	case appcontrol.FieldExternSigninMethods:
		return m.OldExternSigninMethods(ctx)
	case appcontrol.FieldRecaptchaMethod:
		return m.OldRecaptchaMethod(ctx)
	case appcontrol.FieldKycEnable:
		return m.OldKycEnable(ctx)
	case appcontrol.FieldSigninVerifyEnable:
		return m.OldSigninVerifyEnable(ctx)
	case appcontrol.FieldInvitationCodeMust:
		return m.OldInvitationCodeMust(ctx)
	}
	return nil, fmt.Errorf("unknown AppControl field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppControlMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appcontrol.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appcontrol.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appcontrol.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appcontrol.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appcontrol.FieldSignupMethods:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignupMethods(v)
		return nil
	case appcontrol.FieldExternSigninMethods:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternSigninMethods(v)
		return nil
	case appcontrol.FieldRecaptchaMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecaptchaMethod(v)
		return nil
	case appcontrol.FieldKycEnable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKycEnable(v)
		return nil
	case appcontrol.FieldSigninVerifyEnable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSigninVerifyEnable(v)
		return nil
	case appcontrol.FieldInvitationCodeMust:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvitationCodeMust(v)
		return nil
	}
	return fmt.Errorf("unknown AppControl field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppControlMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, appcontrol.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, appcontrol.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, appcontrol.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppControlMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appcontrol.FieldCreatedAt:
		return m.AddedCreatedAt()
	case appcontrol.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case appcontrol.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppControlMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appcontrol.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case appcontrol.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case appcontrol.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppControl numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppControlMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appcontrol.FieldAppID) {
		fields = append(fields, appcontrol.FieldAppID)
	}
	if m.FieldCleared(appcontrol.FieldSignupMethods) {
		fields = append(fields, appcontrol.FieldSignupMethods)
	}
	if m.FieldCleared(appcontrol.FieldExternSigninMethods) {
		fields = append(fields, appcontrol.FieldExternSigninMethods)
	}
	if m.FieldCleared(appcontrol.FieldRecaptchaMethod) {
		fields = append(fields, appcontrol.FieldRecaptchaMethod)
	}
	if m.FieldCleared(appcontrol.FieldKycEnable) {
		fields = append(fields, appcontrol.FieldKycEnable)
	}
	if m.FieldCleared(appcontrol.FieldSigninVerifyEnable) {
		fields = append(fields, appcontrol.FieldSigninVerifyEnable)
	}
	if m.FieldCleared(appcontrol.FieldInvitationCodeMust) {
		fields = append(fields, appcontrol.FieldInvitationCodeMust)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppControlMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppControlMutation) ClearField(name string) error {
	switch name {
	case appcontrol.FieldAppID:
		m.ClearAppID()
		return nil
	case appcontrol.FieldSignupMethods:
		m.ClearSignupMethods()
		return nil
	case appcontrol.FieldExternSigninMethods:
		m.ClearExternSigninMethods()
		return nil
	case appcontrol.FieldRecaptchaMethod:
		m.ClearRecaptchaMethod()
		return nil
	case appcontrol.FieldKycEnable:
		m.ClearKycEnable()
		return nil
	case appcontrol.FieldSigninVerifyEnable:
		m.ClearSigninVerifyEnable()
		return nil
	case appcontrol.FieldInvitationCodeMust:
		m.ClearInvitationCodeMust()
		return nil
	}
	return fmt.Errorf("unknown AppControl nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppControlMutation) ResetField(name string) error {
	switch name {
	case appcontrol.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appcontrol.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appcontrol.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appcontrol.FieldAppID:
		m.ResetAppID()
		return nil
	case appcontrol.FieldSignupMethods:
		m.ResetSignupMethods()
		return nil
	case appcontrol.FieldExternSigninMethods:
		m.ResetExternSigninMethods()
		return nil
	case appcontrol.FieldRecaptchaMethod:
		m.ResetRecaptchaMethod()
		return nil
	case appcontrol.FieldKycEnable:
		m.ResetKycEnable()
		return nil
	case appcontrol.FieldSigninVerifyEnable:
		m.ResetSigninVerifyEnable()
		return nil
	case appcontrol.FieldInvitationCodeMust:
		m.ResetInvitationCodeMust()
		return nil
	}
	return fmt.Errorf("unknown AppControl field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppControlMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppControlMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppControlMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppControlMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppControlMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppControlMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppControlMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppControl unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppControlMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppControl edge %s", name)
}

// AppRoleMutation represents an operation that mutates the AppRole nodes in the graph.
type AppRoleMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	created_by    *uuid.UUID
	role          *string
	description   *string
	app_id        *uuid.UUID
	_default      *bool
	genesis       *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AppRole, error)
	predicates    []predicate.AppRole
}

var _ ent.Mutation = (*AppRoleMutation)(nil)

// approleOption allows management of the mutation configuration using functional options.
type approleOption func(*AppRoleMutation)

// newAppRoleMutation creates new mutation for the AppRole entity.
func newAppRoleMutation(c config, op Op, opts ...approleOption) *AppRoleMutation {
	m := &AppRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeAppRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppRoleID sets the ID field of the mutation.
func withAppRoleID(id uuid.UUID) approleOption {
	return func(m *AppRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *AppRole
		)
		m.oldValue = func(ctx context.Context) (*AppRole, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppRole sets the old AppRole of the mutation.
func withAppRole(node *AppRole) approleOption {
	return func(m *AppRoleMutation) {
		m.oldValue = func(context.Context) (*AppRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppRole entities.
func (m *AppRoleMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppRoleMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppRoleMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppRole.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppRoleMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppRoleMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppRoleMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppRoleMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppRoleMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppRoleMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppRoleMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppRoleMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppRoleMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppRoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppRoleMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppRoleMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppRoleMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppRoleMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppRoleMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *AppRoleMutation) SetCreatedBy(u uuid.UUID) {
	m.created_by = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AppRoleMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *AppRoleMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[approle.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *AppRoleMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[approle.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AppRoleMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, approle.FieldCreatedBy)
}

// SetRole sets the "role" field.
func (m *AppRoleMutation) SetRole(s string) {
	m.role = &s
}

// Role returns the value of the "role" field in the mutation.
func (m *AppRoleMutation) Role() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ClearRole clears the value of the "role" field.
func (m *AppRoleMutation) ClearRole() {
	m.role = nil
	m.clearedFields[approle.FieldRole] = struct{}{}
}

// RoleCleared returns if the "role" field was cleared in this mutation.
func (m *AppRoleMutation) RoleCleared() bool {
	_, ok := m.clearedFields[approle.FieldRole]
	return ok
}

// ResetRole resets all changes to the "role" field.
func (m *AppRoleMutation) ResetRole() {
	m.role = nil
	delete(m.clearedFields, approle.FieldRole)
}

// SetDescription sets the "description" field.
func (m *AppRoleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AppRoleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AppRoleMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[approle.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AppRoleMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[approle.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AppRoleMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, approle.FieldDescription)
}

// SetAppID sets the "app_id" field.
func (m *AppRoleMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppRoleMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *AppRoleMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[approle.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *AppRoleMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[approle.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppRoleMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, approle.FieldAppID)
}

// SetDefault sets the "default" field.
func (m *AppRoleMutation) SetDefault(b bool) {
	m._default = &b
}

// Default returns the value of the "default" field in the mutation.
func (m *AppRoleMutation) Default() (r bool, exists bool) {
	v := m._default
	if v == nil {
		return
	}
	return *v, true
}

// OldDefault returns the old "default" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefault: %w", err)
	}
	return oldValue.Default, nil
}

// ClearDefault clears the value of the "default" field.
func (m *AppRoleMutation) ClearDefault() {
	m._default = nil
	m.clearedFields[approle.FieldDefault] = struct{}{}
}

// DefaultCleared returns if the "default" field was cleared in this mutation.
func (m *AppRoleMutation) DefaultCleared() bool {
	_, ok := m.clearedFields[approle.FieldDefault]
	return ok
}

// ResetDefault resets all changes to the "default" field.
func (m *AppRoleMutation) ResetDefault() {
	m._default = nil
	delete(m.clearedFields, approle.FieldDefault)
}

// SetGenesis sets the "genesis" field.
func (m *AppRoleMutation) SetGenesis(b bool) {
	m.genesis = &b
}

// Genesis returns the value of the "genesis" field in the mutation.
func (m *AppRoleMutation) Genesis() (r bool, exists bool) {
	v := m.genesis
	if v == nil {
		return
	}
	return *v, true
}

// OldGenesis returns the old "genesis" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldGenesis(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGenesis is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGenesis requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGenesis: %w", err)
	}
	return oldValue.Genesis, nil
}

// ClearGenesis clears the value of the "genesis" field.
func (m *AppRoleMutation) ClearGenesis() {
	m.genesis = nil
	m.clearedFields[approle.FieldGenesis] = struct{}{}
}

// GenesisCleared returns if the "genesis" field was cleared in this mutation.
func (m *AppRoleMutation) GenesisCleared() bool {
	_, ok := m.clearedFields[approle.FieldGenesis]
	return ok
}

// ResetGenesis resets all changes to the "genesis" field.
func (m *AppRoleMutation) ResetGenesis() {
	m.genesis = nil
	delete(m.clearedFields, approle.FieldGenesis)
}

// Where appends a list predicates to the AppRoleMutation builder.
func (m *AppRoleMutation) Where(ps ...predicate.AppRole) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AppRoleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AppRole).
func (m *AppRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppRoleMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, approle.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, approle.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, approle.FieldDeletedAt)
	}
	if m.created_by != nil {
		fields = append(fields, approle.FieldCreatedBy)
	}
	if m.role != nil {
		fields = append(fields, approle.FieldRole)
	}
	if m.description != nil {
		fields = append(fields, approle.FieldDescription)
	}
	if m.app_id != nil {
		fields = append(fields, approle.FieldAppID)
	}
	if m._default != nil {
		fields = append(fields, approle.FieldDefault)
	}
	if m.genesis != nil {
		fields = append(fields, approle.FieldGenesis)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case approle.FieldCreatedAt:
		return m.CreatedAt()
	case approle.FieldUpdatedAt:
		return m.UpdatedAt()
	case approle.FieldDeletedAt:
		return m.DeletedAt()
	case approle.FieldCreatedBy:
		return m.CreatedBy()
	case approle.FieldRole:
		return m.Role()
	case approle.FieldDescription:
		return m.Description()
	case approle.FieldAppID:
		return m.AppID()
	case approle.FieldDefault:
		return m.Default()
	case approle.FieldGenesis:
		return m.Genesis()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case approle.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case approle.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case approle.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case approle.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case approle.FieldRole:
		return m.OldRole(ctx)
	case approle.FieldDescription:
		return m.OldDescription(ctx)
	case approle.FieldAppID:
		return m.OldAppID(ctx)
	case approle.FieldDefault:
		return m.OldDefault(ctx)
	case approle.FieldGenesis:
		return m.OldGenesis(ctx)
	}
	return nil, fmt.Errorf("unknown AppRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case approle.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case approle.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case approle.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case approle.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case approle.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case approle.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case approle.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case approle.FieldDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefault(v)
		return nil
	case approle.FieldGenesis:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGenesis(v)
		return nil
	}
	return fmt.Errorf("unknown AppRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppRoleMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, approle.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, approle.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, approle.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppRoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case approle.FieldCreatedAt:
		return m.AddedCreatedAt()
	case approle.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case approle.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case approle.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case approle.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case approle.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppRoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(approle.FieldCreatedBy) {
		fields = append(fields, approle.FieldCreatedBy)
	}
	if m.FieldCleared(approle.FieldRole) {
		fields = append(fields, approle.FieldRole)
	}
	if m.FieldCleared(approle.FieldDescription) {
		fields = append(fields, approle.FieldDescription)
	}
	if m.FieldCleared(approle.FieldAppID) {
		fields = append(fields, approle.FieldAppID)
	}
	if m.FieldCleared(approle.FieldDefault) {
		fields = append(fields, approle.FieldDefault)
	}
	if m.FieldCleared(approle.FieldGenesis) {
		fields = append(fields, approle.FieldGenesis)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppRoleMutation) ClearField(name string) error {
	switch name {
	case approle.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case approle.FieldRole:
		m.ClearRole()
		return nil
	case approle.FieldDescription:
		m.ClearDescription()
		return nil
	case approle.FieldAppID:
		m.ClearAppID()
		return nil
	case approle.FieldDefault:
		m.ClearDefault()
		return nil
	case approle.FieldGenesis:
		m.ClearGenesis()
		return nil
	}
	return fmt.Errorf("unknown AppRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppRoleMutation) ResetField(name string) error {
	switch name {
	case approle.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case approle.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case approle.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case approle.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case approle.FieldRole:
		m.ResetRole()
		return nil
	case approle.FieldDescription:
		m.ResetDescription()
		return nil
	case approle.FieldAppID:
		m.ResetAppID()
		return nil
	case approle.FieldDefault:
		m.ResetDefault()
		return nil
	case approle.FieldGenesis:
		m.ResetGenesis()
		return nil
	}
	return fmt.Errorf("unknown AppRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppRoleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppRoleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppRoleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppRoleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppRoleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppRole edge %s", name)
}

// AppRoleUserMutation represents an operation that mutates the AppRoleUser nodes in the graph.
type AppRoleUserMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	app_id        *uuid.UUID
	role_id       *uuid.UUID
	user_id       *uuid.UUID
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AppRoleUser, error)
	predicates    []predicate.AppRoleUser
}

var _ ent.Mutation = (*AppRoleUserMutation)(nil)

// approleuserOption allows management of the mutation configuration using functional options.
type approleuserOption func(*AppRoleUserMutation)

// newAppRoleUserMutation creates new mutation for the AppRoleUser entity.
func newAppRoleUserMutation(c config, op Op, opts ...approleuserOption) *AppRoleUserMutation {
	m := &AppRoleUserMutation{
		config:        c,
		op:            op,
		typ:           TypeAppRoleUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppRoleUserID sets the ID field of the mutation.
func withAppRoleUserID(id uuid.UUID) approleuserOption {
	return func(m *AppRoleUserMutation) {
		var (
			err   error
			once  sync.Once
			value *AppRoleUser
		)
		m.oldValue = func(ctx context.Context) (*AppRoleUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppRoleUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppRoleUser sets the old AppRoleUser of the mutation.
func withAppRoleUser(node *AppRoleUser) approleuserOption {
	return func(m *AppRoleUserMutation) {
		m.oldValue = func(context.Context) (*AppRoleUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppRoleUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppRoleUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppRoleUser entities.
func (m *AppRoleUserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppRoleUserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppRoleUserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppRoleUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppRoleUserMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppRoleUserMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppRoleUser entity.
// If the AppRoleUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleUserMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppRoleUserMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppRoleUserMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppRoleUserMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppRoleUserMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppRoleUserMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppRoleUser entity.
// If the AppRoleUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleUserMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppRoleUserMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppRoleUserMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppRoleUserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppRoleUserMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppRoleUserMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppRoleUser entity.
// If the AppRoleUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleUserMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppRoleUserMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppRoleUserMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppRoleUserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *AppRoleUserMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppRoleUserMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppRoleUser entity.
// If the AppRoleUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleUserMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *AppRoleUserMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[approleuser.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *AppRoleUserMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[approleuser.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppRoleUserMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, approleuser.FieldAppID)
}

// SetRoleID sets the "role_id" field.
func (m *AppRoleUserMutation) SetRoleID(u uuid.UUID) {
	m.role_id = &u
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *AppRoleUserMutation) RoleID() (r uuid.UUID, exists bool) {
	v := m.role_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the AppRoleUser entity.
// If the AppRoleUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleUserMutation) OldRoleID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ClearRoleID clears the value of the "role_id" field.
func (m *AppRoleUserMutation) ClearRoleID() {
	m.role_id = nil
	m.clearedFields[approleuser.FieldRoleID] = struct{}{}
}

// RoleIDCleared returns if the "role_id" field was cleared in this mutation.
func (m *AppRoleUserMutation) RoleIDCleared() bool {
	_, ok := m.clearedFields[approleuser.FieldRoleID]
	return ok
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *AppRoleUserMutation) ResetRoleID() {
	m.role_id = nil
	delete(m.clearedFields, approleuser.FieldRoleID)
}

// SetUserID sets the "user_id" field.
func (m *AppRoleUserMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AppRoleUserMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AppRoleUser entity.
// If the AppRoleUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleUserMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *AppRoleUserMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[approleuser.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *AppRoleUserMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[approleuser.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AppRoleUserMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, approleuser.FieldUserID)
}

// Where appends a list predicates to the AppRoleUserMutation builder.
func (m *AppRoleUserMutation) Where(ps ...predicate.AppRoleUser) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AppRoleUserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AppRoleUser).
func (m *AppRoleUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppRoleUserMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, approleuser.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, approleuser.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, approleuser.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, approleuser.FieldAppID)
	}
	if m.role_id != nil {
		fields = append(fields, approleuser.FieldRoleID)
	}
	if m.user_id != nil {
		fields = append(fields, approleuser.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppRoleUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case approleuser.FieldCreatedAt:
		return m.CreatedAt()
	case approleuser.FieldUpdatedAt:
		return m.UpdatedAt()
	case approleuser.FieldDeletedAt:
		return m.DeletedAt()
	case approleuser.FieldAppID:
		return m.AppID()
	case approleuser.FieldRoleID:
		return m.RoleID()
	case approleuser.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppRoleUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case approleuser.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case approleuser.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case approleuser.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case approleuser.FieldAppID:
		return m.OldAppID(ctx)
	case approleuser.FieldRoleID:
		return m.OldRoleID(ctx)
	case approleuser.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown AppRoleUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppRoleUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case approleuser.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case approleuser.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case approleuser.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case approleuser.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case approleuser.FieldRoleID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case approleuser.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown AppRoleUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppRoleUserMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, approleuser.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, approleuser.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, approleuser.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppRoleUserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case approleuser.FieldCreatedAt:
		return m.AddedCreatedAt()
	case approleuser.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case approleuser.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppRoleUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case approleuser.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case approleuser.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case approleuser.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppRoleUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppRoleUserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(approleuser.FieldAppID) {
		fields = append(fields, approleuser.FieldAppID)
	}
	if m.FieldCleared(approleuser.FieldRoleID) {
		fields = append(fields, approleuser.FieldRoleID)
	}
	if m.FieldCleared(approleuser.FieldUserID) {
		fields = append(fields, approleuser.FieldUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppRoleUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppRoleUserMutation) ClearField(name string) error {
	switch name {
	case approleuser.FieldAppID:
		m.ClearAppID()
		return nil
	case approleuser.FieldRoleID:
		m.ClearRoleID()
		return nil
	case approleuser.FieldUserID:
		m.ClearUserID()
		return nil
	}
	return fmt.Errorf("unknown AppRoleUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppRoleUserMutation) ResetField(name string) error {
	switch name {
	case approleuser.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case approleuser.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case approleuser.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case approleuser.FieldAppID:
		m.ResetAppID()
		return nil
	case approleuser.FieldRoleID:
		m.ResetRoleID()
		return nil
	case approleuser.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown AppRoleUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppRoleUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppRoleUserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppRoleUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppRoleUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppRoleUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppRoleUserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppRoleUserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppRoleUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppRoleUserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppRoleUser edge %s", name)
}

// AppUserMutation represents an operation that mutates the AppUser nodes in the graph.
type AppUserMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	created_at      *uint32
	addcreated_at   *int32
	updated_at      *uint32
	addupdated_at   *int32
	deleted_at      *uint32
	adddeleted_at   *int32
	app_id          *uuid.UUID
	email_address   *string
	phone_no        *string
	import_from_app *uuid.UUID
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*AppUser, error)
	predicates      []predicate.AppUser
}

var _ ent.Mutation = (*AppUserMutation)(nil)

// appuserOption allows management of the mutation configuration using functional options.
type appuserOption func(*AppUserMutation)

// newAppUserMutation creates new mutation for the AppUser entity.
func newAppUserMutation(c config, op Op, opts ...appuserOption) *AppUserMutation {
	m := &AppUserMutation{
		config:        c,
		op:            op,
		typ:           TypeAppUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppUserID sets the ID field of the mutation.
func withAppUserID(id uuid.UUID) appuserOption {
	return func(m *AppUserMutation) {
		var (
			err   error
			once  sync.Once
			value *AppUser
		)
		m.oldValue = func(ctx context.Context) (*AppUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppUser sets the old AppUser of the mutation.
func withAppUser(node *AppUser) appuserOption {
	return func(m *AppUserMutation) {
		m.oldValue = func(context.Context) (*AppUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppUser entities.
func (m *AppUserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppUserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppUserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppUserMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppUserMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppUserMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppUserMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppUserMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppUserMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppUserMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppUserMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppUserMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppUserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppUserMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppUserMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppUserMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppUserMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppUserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *AppUserMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppUserMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *AppUserMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[appuser.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *AppUserMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[appuser.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppUserMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, appuser.FieldAppID)
}

// SetEmailAddress sets the "email_address" field.
func (m *AppUserMutation) SetEmailAddress(s string) {
	m.email_address = &s
}

// EmailAddress returns the value of the "email_address" field in the mutation.
func (m *AppUserMutation) EmailAddress() (r string, exists bool) {
	v := m.email_address
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailAddress returns the old "email_address" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldEmailAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailAddress: %w", err)
	}
	return oldValue.EmailAddress, nil
}

// ClearEmailAddress clears the value of the "email_address" field.
func (m *AppUserMutation) ClearEmailAddress() {
	m.email_address = nil
	m.clearedFields[appuser.FieldEmailAddress] = struct{}{}
}

// EmailAddressCleared returns if the "email_address" field was cleared in this mutation.
func (m *AppUserMutation) EmailAddressCleared() bool {
	_, ok := m.clearedFields[appuser.FieldEmailAddress]
	return ok
}

// ResetEmailAddress resets all changes to the "email_address" field.
func (m *AppUserMutation) ResetEmailAddress() {
	m.email_address = nil
	delete(m.clearedFields, appuser.FieldEmailAddress)
}

// SetPhoneNo sets the "phone_no" field.
func (m *AppUserMutation) SetPhoneNo(s string) {
	m.phone_no = &s
}

// PhoneNo returns the value of the "phone_no" field in the mutation.
func (m *AppUserMutation) PhoneNo() (r string, exists bool) {
	v := m.phone_no
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNo returns the old "phone_no" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldPhoneNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNo: %w", err)
	}
	return oldValue.PhoneNo, nil
}

// ClearPhoneNo clears the value of the "phone_no" field.
func (m *AppUserMutation) ClearPhoneNo() {
	m.phone_no = nil
	m.clearedFields[appuser.FieldPhoneNo] = struct{}{}
}

// PhoneNoCleared returns if the "phone_no" field was cleared in this mutation.
func (m *AppUserMutation) PhoneNoCleared() bool {
	_, ok := m.clearedFields[appuser.FieldPhoneNo]
	return ok
}

// ResetPhoneNo resets all changes to the "phone_no" field.
func (m *AppUserMutation) ResetPhoneNo() {
	m.phone_no = nil
	delete(m.clearedFields, appuser.FieldPhoneNo)
}

// SetImportFromApp sets the "import_from_app" field.
func (m *AppUserMutation) SetImportFromApp(u uuid.UUID) {
	m.import_from_app = &u
}

// ImportFromApp returns the value of the "import_from_app" field in the mutation.
func (m *AppUserMutation) ImportFromApp() (r uuid.UUID, exists bool) {
	v := m.import_from_app
	if v == nil {
		return
	}
	return *v, true
}

// OldImportFromApp returns the old "import_from_app" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldImportFromApp(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImportFromApp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImportFromApp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImportFromApp: %w", err)
	}
	return oldValue.ImportFromApp, nil
}

// ClearImportFromApp clears the value of the "import_from_app" field.
func (m *AppUserMutation) ClearImportFromApp() {
	m.import_from_app = nil
	m.clearedFields[appuser.FieldImportFromApp] = struct{}{}
}

// ImportFromAppCleared returns if the "import_from_app" field was cleared in this mutation.
func (m *AppUserMutation) ImportFromAppCleared() bool {
	_, ok := m.clearedFields[appuser.FieldImportFromApp]
	return ok
}

// ResetImportFromApp resets all changes to the "import_from_app" field.
func (m *AppUserMutation) ResetImportFromApp() {
	m.import_from_app = nil
	delete(m.clearedFields, appuser.FieldImportFromApp)
}

// Where appends a list predicates to the AppUserMutation builder.
func (m *AppUserMutation) Where(ps ...predicate.AppUser) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AppUserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AppUser).
func (m *AppUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppUserMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, appuser.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appuser.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appuser.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, appuser.FieldAppID)
	}
	if m.email_address != nil {
		fields = append(fields, appuser.FieldEmailAddress)
	}
	if m.phone_no != nil {
		fields = append(fields, appuser.FieldPhoneNo)
	}
	if m.import_from_app != nil {
		fields = append(fields, appuser.FieldImportFromApp)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appuser.FieldCreatedAt:
		return m.CreatedAt()
	case appuser.FieldUpdatedAt:
		return m.UpdatedAt()
	case appuser.FieldDeletedAt:
		return m.DeletedAt()
	case appuser.FieldAppID:
		return m.AppID()
	case appuser.FieldEmailAddress:
		return m.EmailAddress()
	case appuser.FieldPhoneNo:
		return m.PhoneNo()
	case appuser.FieldImportFromApp:
		return m.ImportFromApp()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appuser.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appuser.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appuser.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appuser.FieldAppID:
		return m.OldAppID(ctx)
	case appuser.FieldEmailAddress:
		return m.OldEmailAddress(ctx)
	case appuser.FieldPhoneNo:
		return m.OldPhoneNo(ctx)
	case appuser.FieldImportFromApp:
		return m.OldImportFromApp(ctx)
	}
	return nil, fmt.Errorf("unknown AppUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appuser.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appuser.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appuser.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appuser.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appuser.FieldEmailAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailAddress(v)
		return nil
	case appuser.FieldPhoneNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNo(v)
		return nil
	case appuser.FieldImportFromApp:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImportFromApp(v)
		return nil
	}
	return fmt.Errorf("unknown AppUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppUserMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, appuser.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, appuser.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, appuser.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppUserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appuser.FieldCreatedAt:
		return m.AddedCreatedAt()
	case appuser.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case appuser.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appuser.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case appuser.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case appuser.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppUserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appuser.FieldAppID) {
		fields = append(fields, appuser.FieldAppID)
	}
	if m.FieldCleared(appuser.FieldEmailAddress) {
		fields = append(fields, appuser.FieldEmailAddress)
	}
	if m.FieldCleared(appuser.FieldPhoneNo) {
		fields = append(fields, appuser.FieldPhoneNo)
	}
	if m.FieldCleared(appuser.FieldImportFromApp) {
		fields = append(fields, appuser.FieldImportFromApp)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppUserMutation) ClearField(name string) error {
	switch name {
	case appuser.FieldAppID:
		m.ClearAppID()
		return nil
	case appuser.FieldEmailAddress:
		m.ClearEmailAddress()
		return nil
	case appuser.FieldPhoneNo:
		m.ClearPhoneNo()
		return nil
	case appuser.FieldImportFromApp:
		m.ClearImportFromApp()
		return nil
	}
	return fmt.Errorf("unknown AppUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppUserMutation) ResetField(name string) error {
	switch name {
	case appuser.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appuser.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appuser.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appuser.FieldAppID:
		m.ResetAppID()
		return nil
	case appuser.FieldEmailAddress:
		m.ResetEmailAddress()
		return nil
	case appuser.FieldPhoneNo:
		m.ResetPhoneNo()
		return nil
	case appuser.FieldImportFromApp:
		m.ResetImportFromApp()
		return nil
	}
	return fmt.Errorf("unknown AppUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppUserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppUserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppUserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppUserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppUser edge %s", name)
}

// AppUserControlMutation represents an operation that mutates the AppUserControl nodes in the graph.
type AppUserControlMutation struct {
	config
	op                                     Op
	typ                                    string
	id                                     *uuid.UUID
	created_at                             *uint32
	addcreated_at                          *int32
	updated_at                             *uint32
	addupdated_at                          *int32
	deleted_at                             *uint32
	adddeleted_at                          *int32
	app_id                                 *uuid.UUID
	user_id                                *uuid.UUID
	signin_verify_by_google_authentication *bool
	google_authentication_verified         *bool
	signin_verify_type                     *string
	clearedFields                          map[string]struct{}
	done                                   bool
	oldValue                               func(context.Context) (*AppUserControl, error)
	predicates                             []predicate.AppUserControl
}

var _ ent.Mutation = (*AppUserControlMutation)(nil)

// appusercontrolOption allows management of the mutation configuration using functional options.
type appusercontrolOption func(*AppUserControlMutation)

// newAppUserControlMutation creates new mutation for the AppUserControl entity.
func newAppUserControlMutation(c config, op Op, opts ...appusercontrolOption) *AppUserControlMutation {
	m := &AppUserControlMutation{
		config:        c,
		op:            op,
		typ:           TypeAppUserControl,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppUserControlID sets the ID field of the mutation.
func withAppUserControlID(id uuid.UUID) appusercontrolOption {
	return func(m *AppUserControlMutation) {
		var (
			err   error
			once  sync.Once
			value *AppUserControl
		)
		m.oldValue = func(ctx context.Context) (*AppUserControl, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppUserControl.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppUserControl sets the old AppUserControl of the mutation.
func withAppUserControl(node *AppUserControl) appusercontrolOption {
	return func(m *AppUserControlMutation) {
		m.oldValue = func(context.Context) (*AppUserControl, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppUserControlMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppUserControlMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppUserControl entities.
func (m *AppUserControlMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppUserControlMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppUserControlMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppUserControl.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppUserControlMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppUserControlMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppUserControl entity.
// If the AppUserControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserControlMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppUserControlMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppUserControlMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppUserControlMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppUserControlMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppUserControlMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppUserControl entity.
// If the AppUserControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserControlMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppUserControlMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppUserControlMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppUserControlMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppUserControlMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppUserControlMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppUserControl entity.
// If the AppUserControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserControlMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppUserControlMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppUserControlMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppUserControlMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *AppUserControlMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppUserControlMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppUserControl entity.
// If the AppUserControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserControlMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *AppUserControlMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[appusercontrol.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *AppUserControlMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[appusercontrol.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppUserControlMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, appusercontrol.FieldAppID)
}

// SetUserID sets the "user_id" field.
func (m *AppUserControlMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AppUserControlMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AppUserControl entity.
// If the AppUserControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserControlMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *AppUserControlMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[appusercontrol.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *AppUserControlMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[appusercontrol.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AppUserControlMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, appusercontrol.FieldUserID)
}

// SetSigninVerifyByGoogleAuthentication sets the "signin_verify_by_google_authentication" field.
func (m *AppUserControlMutation) SetSigninVerifyByGoogleAuthentication(b bool) {
	m.signin_verify_by_google_authentication = &b
}

// SigninVerifyByGoogleAuthentication returns the value of the "signin_verify_by_google_authentication" field in the mutation.
func (m *AppUserControlMutation) SigninVerifyByGoogleAuthentication() (r bool, exists bool) {
	v := m.signin_verify_by_google_authentication
	if v == nil {
		return
	}
	return *v, true
}

// OldSigninVerifyByGoogleAuthentication returns the old "signin_verify_by_google_authentication" field's value of the AppUserControl entity.
// If the AppUserControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserControlMutation) OldSigninVerifyByGoogleAuthentication(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSigninVerifyByGoogleAuthentication is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSigninVerifyByGoogleAuthentication requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSigninVerifyByGoogleAuthentication: %w", err)
	}
	return oldValue.SigninVerifyByGoogleAuthentication, nil
}

// ClearSigninVerifyByGoogleAuthentication clears the value of the "signin_verify_by_google_authentication" field.
func (m *AppUserControlMutation) ClearSigninVerifyByGoogleAuthentication() {
	m.signin_verify_by_google_authentication = nil
	m.clearedFields[appusercontrol.FieldSigninVerifyByGoogleAuthentication] = struct{}{}
}

// SigninVerifyByGoogleAuthenticationCleared returns if the "signin_verify_by_google_authentication" field was cleared in this mutation.
func (m *AppUserControlMutation) SigninVerifyByGoogleAuthenticationCleared() bool {
	_, ok := m.clearedFields[appusercontrol.FieldSigninVerifyByGoogleAuthentication]
	return ok
}

// ResetSigninVerifyByGoogleAuthentication resets all changes to the "signin_verify_by_google_authentication" field.
func (m *AppUserControlMutation) ResetSigninVerifyByGoogleAuthentication() {
	m.signin_verify_by_google_authentication = nil
	delete(m.clearedFields, appusercontrol.FieldSigninVerifyByGoogleAuthentication)
}

// SetGoogleAuthenticationVerified sets the "google_authentication_verified" field.
func (m *AppUserControlMutation) SetGoogleAuthenticationVerified(b bool) {
	m.google_authentication_verified = &b
}

// GoogleAuthenticationVerified returns the value of the "google_authentication_verified" field in the mutation.
func (m *AppUserControlMutation) GoogleAuthenticationVerified() (r bool, exists bool) {
	v := m.google_authentication_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldGoogleAuthenticationVerified returns the old "google_authentication_verified" field's value of the AppUserControl entity.
// If the AppUserControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserControlMutation) OldGoogleAuthenticationVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoogleAuthenticationVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoogleAuthenticationVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoogleAuthenticationVerified: %w", err)
	}
	return oldValue.GoogleAuthenticationVerified, nil
}

// ClearGoogleAuthenticationVerified clears the value of the "google_authentication_verified" field.
func (m *AppUserControlMutation) ClearGoogleAuthenticationVerified() {
	m.google_authentication_verified = nil
	m.clearedFields[appusercontrol.FieldGoogleAuthenticationVerified] = struct{}{}
}

// GoogleAuthenticationVerifiedCleared returns if the "google_authentication_verified" field was cleared in this mutation.
func (m *AppUserControlMutation) GoogleAuthenticationVerifiedCleared() bool {
	_, ok := m.clearedFields[appusercontrol.FieldGoogleAuthenticationVerified]
	return ok
}

// ResetGoogleAuthenticationVerified resets all changes to the "google_authentication_verified" field.
func (m *AppUserControlMutation) ResetGoogleAuthenticationVerified() {
	m.google_authentication_verified = nil
	delete(m.clearedFields, appusercontrol.FieldGoogleAuthenticationVerified)
}

// SetSigninVerifyType sets the "signin_verify_type" field.
func (m *AppUserControlMutation) SetSigninVerifyType(s string) {
	m.signin_verify_type = &s
}

// SigninVerifyType returns the value of the "signin_verify_type" field in the mutation.
func (m *AppUserControlMutation) SigninVerifyType() (r string, exists bool) {
	v := m.signin_verify_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSigninVerifyType returns the old "signin_verify_type" field's value of the AppUserControl entity.
// If the AppUserControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserControlMutation) OldSigninVerifyType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSigninVerifyType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSigninVerifyType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSigninVerifyType: %w", err)
	}
	return oldValue.SigninVerifyType, nil
}

// ClearSigninVerifyType clears the value of the "signin_verify_type" field.
func (m *AppUserControlMutation) ClearSigninVerifyType() {
	m.signin_verify_type = nil
	m.clearedFields[appusercontrol.FieldSigninVerifyType] = struct{}{}
}

// SigninVerifyTypeCleared returns if the "signin_verify_type" field was cleared in this mutation.
func (m *AppUserControlMutation) SigninVerifyTypeCleared() bool {
	_, ok := m.clearedFields[appusercontrol.FieldSigninVerifyType]
	return ok
}

// ResetSigninVerifyType resets all changes to the "signin_verify_type" field.
func (m *AppUserControlMutation) ResetSigninVerifyType() {
	m.signin_verify_type = nil
	delete(m.clearedFields, appusercontrol.FieldSigninVerifyType)
}

// Where appends a list predicates to the AppUserControlMutation builder.
func (m *AppUserControlMutation) Where(ps ...predicate.AppUserControl) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AppUserControlMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AppUserControl).
func (m *AppUserControlMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppUserControlMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, appusercontrol.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appusercontrol.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appusercontrol.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, appusercontrol.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, appusercontrol.FieldUserID)
	}
	if m.signin_verify_by_google_authentication != nil {
		fields = append(fields, appusercontrol.FieldSigninVerifyByGoogleAuthentication)
	}
	if m.google_authentication_verified != nil {
		fields = append(fields, appusercontrol.FieldGoogleAuthenticationVerified)
	}
	if m.signin_verify_type != nil {
		fields = append(fields, appusercontrol.FieldSigninVerifyType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppUserControlMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appusercontrol.FieldCreatedAt:
		return m.CreatedAt()
	case appusercontrol.FieldUpdatedAt:
		return m.UpdatedAt()
	case appusercontrol.FieldDeletedAt:
		return m.DeletedAt()
	case appusercontrol.FieldAppID:
		return m.AppID()
	case appusercontrol.FieldUserID:
		return m.UserID()
	case appusercontrol.FieldSigninVerifyByGoogleAuthentication:
		return m.SigninVerifyByGoogleAuthentication()
	case appusercontrol.FieldGoogleAuthenticationVerified:
		return m.GoogleAuthenticationVerified()
	case appusercontrol.FieldSigninVerifyType:
		return m.SigninVerifyType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppUserControlMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appusercontrol.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appusercontrol.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appusercontrol.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appusercontrol.FieldAppID:
		return m.OldAppID(ctx)
	case appusercontrol.FieldUserID:
		return m.OldUserID(ctx)
	case appusercontrol.FieldSigninVerifyByGoogleAuthentication:
		return m.OldSigninVerifyByGoogleAuthentication(ctx)
	case appusercontrol.FieldGoogleAuthenticationVerified:
		return m.OldGoogleAuthenticationVerified(ctx)
	case appusercontrol.FieldSigninVerifyType:
		return m.OldSigninVerifyType(ctx)
	}
	return nil, fmt.Errorf("unknown AppUserControl field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppUserControlMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appusercontrol.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appusercontrol.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appusercontrol.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appusercontrol.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appusercontrol.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case appusercontrol.FieldSigninVerifyByGoogleAuthentication:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSigninVerifyByGoogleAuthentication(v)
		return nil
	case appusercontrol.FieldGoogleAuthenticationVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoogleAuthenticationVerified(v)
		return nil
	case appusercontrol.FieldSigninVerifyType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSigninVerifyType(v)
		return nil
	}
	return fmt.Errorf("unknown AppUserControl field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppUserControlMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, appusercontrol.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, appusercontrol.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, appusercontrol.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppUserControlMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appusercontrol.FieldCreatedAt:
		return m.AddedCreatedAt()
	case appusercontrol.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case appusercontrol.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppUserControlMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appusercontrol.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case appusercontrol.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case appusercontrol.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppUserControl numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppUserControlMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appusercontrol.FieldAppID) {
		fields = append(fields, appusercontrol.FieldAppID)
	}
	if m.FieldCleared(appusercontrol.FieldUserID) {
		fields = append(fields, appusercontrol.FieldUserID)
	}
	if m.FieldCleared(appusercontrol.FieldSigninVerifyByGoogleAuthentication) {
		fields = append(fields, appusercontrol.FieldSigninVerifyByGoogleAuthentication)
	}
	if m.FieldCleared(appusercontrol.FieldGoogleAuthenticationVerified) {
		fields = append(fields, appusercontrol.FieldGoogleAuthenticationVerified)
	}
	if m.FieldCleared(appusercontrol.FieldSigninVerifyType) {
		fields = append(fields, appusercontrol.FieldSigninVerifyType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppUserControlMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppUserControlMutation) ClearField(name string) error {
	switch name {
	case appusercontrol.FieldAppID:
		m.ClearAppID()
		return nil
	case appusercontrol.FieldUserID:
		m.ClearUserID()
		return nil
	case appusercontrol.FieldSigninVerifyByGoogleAuthentication:
		m.ClearSigninVerifyByGoogleAuthentication()
		return nil
	case appusercontrol.FieldGoogleAuthenticationVerified:
		m.ClearGoogleAuthenticationVerified()
		return nil
	case appusercontrol.FieldSigninVerifyType:
		m.ClearSigninVerifyType()
		return nil
	}
	return fmt.Errorf("unknown AppUserControl nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppUserControlMutation) ResetField(name string) error {
	switch name {
	case appusercontrol.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appusercontrol.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appusercontrol.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appusercontrol.FieldAppID:
		m.ResetAppID()
		return nil
	case appusercontrol.FieldUserID:
		m.ResetUserID()
		return nil
	case appusercontrol.FieldSigninVerifyByGoogleAuthentication:
		m.ResetSigninVerifyByGoogleAuthentication()
		return nil
	case appusercontrol.FieldGoogleAuthenticationVerified:
		m.ResetGoogleAuthenticationVerified()
		return nil
	case appusercontrol.FieldSigninVerifyType:
		m.ResetSigninVerifyType()
		return nil
	}
	return fmt.Errorf("unknown AppUserControl field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppUserControlMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppUserControlMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppUserControlMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppUserControlMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppUserControlMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppUserControlMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppUserControlMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppUserControl unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppUserControlMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppUserControl edge %s", name)
}

// AppUserExtraMutation represents an operation that mutates the AppUserExtra nodes in the graph.
type AppUserExtraMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	created_at     *uint32
	addcreated_at  *int32
	updated_at     *uint32
	addupdated_at  *int32
	deleted_at     *uint32
	adddeleted_at  *int32
	app_id         *uuid.UUID
	user_id        *uuid.UUID
	username       *string
	first_name     *string
	last_name      *string
	address_fields *[]string
	gender         *string
	postal_code    *string
	age            *uint32
	addage         *int32
	birthday       *uint32
	addbirthday    *int32
	avatar         *string
	organization   *string
	id_number      *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*AppUserExtra, error)
	predicates     []predicate.AppUserExtra
}

var _ ent.Mutation = (*AppUserExtraMutation)(nil)

// appuserextraOption allows management of the mutation configuration using functional options.
type appuserextraOption func(*AppUserExtraMutation)

// newAppUserExtraMutation creates new mutation for the AppUserExtra entity.
func newAppUserExtraMutation(c config, op Op, opts ...appuserextraOption) *AppUserExtraMutation {
	m := &AppUserExtraMutation{
		config:        c,
		op:            op,
		typ:           TypeAppUserExtra,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppUserExtraID sets the ID field of the mutation.
func withAppUserExtraID(id uuid.UUID) appuserextraOption {
	return func(m *AppUserExtraMutation) {
		var (
			err   error
			once  sync.Once
			value *AppUserExtra
		)
		m.oldValue = func(ctx context.Context) (*AppUserExtra, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppUserExtra.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppUserExtra sets the old AppUserExtra of the mutation.
func withAppUserExtra(node *AppUserExtra) appuserextraOption {
	return func(m *AppUserExtraMutation) {
		m.oldValue = func(context.Context) (*AppUserExtra, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppUserExtraMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppUserExtraMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppUserExtra entities.
func (m *AppUserExtraMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppUserExtraMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppUserExtraMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppUserExtra.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppUserExtraMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppUserExtraMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppUserExtraMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppUserExtraMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppUserExtraMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppUserExtraMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppUserExtraMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppUserExtraMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppUserExtraMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppUserExtraMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppUserExtraMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppUserExtraMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppUserExtraMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppUserExtraMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppUserExtraMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *AppUserExtraMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppUserExtraMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppUserExtraMutation) ResetAppID() {
	m.app_id = nil
}

// SetUserID sets the "user_id" field.
func (m *AppUserExtraMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AppUserExtraMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AppUserExtraMutation) ResetUserID() {
	m.user_id = nil
}

// SetUsername sets the "username" field.
func (m *AppUserExtraMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *AppUserExtraMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *AppUserExtraMutation) ResetUsername() {
	m.username = nil
}

// SetFirstName sets the "first_name" field.
func (m *AppUserExtraMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *AppUserExtraMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *AppUserExtraMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *AppUserExtraMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *AppUserExtraMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *AppUserExtraMutation) ResetLastName() {
	m.last_name = nil
}

// SetAddressFields sets the "address_fields" field.
func (m *AppUserExtraMutation) SetAddressFields(s []string) {
	m.address_fields = &s
}

// AddressFields returns the value of the "address_fields" field in the mutation.
func (m *AppUserExtraMutation) AddressFields() (r []string, exists bool) {
	v := m.address_fields
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressFields returns the old "address_fields" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldAddressFields(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddressFields is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddressFields requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressFields: %w", err)
	}
	return oldValue.AddressFields, nil
}

// ResetAddressFields resets all changes to the "address_fields" field.
func (m *AppUserExtraMutation) ResetAddressFields() {
	m.address_fields = nil
}

// SetGender sets the "gender" field.
func (m *AppUserExtraMutation) SetGender(s string) {
	m.gender = &s
}

// Gender returns the value of the "gender" field in the mutation.
func (m *AppUserExtraMutation) Gender() (r string, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldGender(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ResetGender resets all changes to the "gender" field.
func (m *AppUserExtraMutation) ResetGender() {
	m.gender = nil
}

// SetPostalCode sets the "postal_code" field.
func (m *AppUserExtraMutation) SetPostalCode(s string) {
	m.postal_code = &s
}

// PostalCode returns the value of the "postal_code" field in the mutation.
func (m *AppUserExtraMutation) PostalCode() (r string, exists bool) {
	v := m.postal_code
	if v == nil {
		return
	}
	return *v, true
}

// OldPostalCode returns the old "postal_code" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldPostalCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostalCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostalCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostalCode: %w", err)
	}
	return oldValue.PostalCode, nil
}

// ResetPostalCode resets all changes to the "postal_code" field.
func (m *AppUserExtraMutation) ResetPostalCode() {
	m.postal_code = nil
}

// SetAge sets the "age" field.
func (m *AppUserExtraMutation) SetAge(u uint32) {
	m.age = &u
	m.addage = nil
}

// Age returns the value of the "age" field in the mutation.
func (m *AppUserExtraMutation) Age() (r uint32, exists bool) {
	v := m.age
	if v == nil {
		return
	}
	return *v, true
}

// OldAge returns the old "age" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldAge(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAge: %w", err)
	}
	return oldValue.Age, nil
}

// AddAge adds u to the "age" field.
func (m *AppUserExtraMutation) AddAge(u int32) {
	if m.addage != nil {
		*m.addage += u
	} else {
		m.addage = &u
	}
}

// AddedAge returns the value that was added to the "age" field in this mutation.
func (m *AppUserExtraMutation) AddedAge() (r int32, exists bool) {
	v := m.addage
	if v == nil {
		return
	}
	return *v, true
}

// ResetAge resets all changes to the "age" field.
func (m *AppUserExtraMutation) ResetAge() {
	m.age = nil
	m.addage = nil
}

// SetBirthday sets the "birthday" field.
func (m *AppUserExtraMutation) SetBirthday(u uint32) {
	m.birthday = &u
	m.addbirthday = nil
}

// Birthday returns the value of the "birthday" field in the mutation.
func (m *AppUserExtraMutation) Birthday() (r uint32, exists bool) {
	v := m.birthday
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthday returns the old "birthday" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldBirthday(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirthday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirthday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthday: %w", err)
	}
	return oldValue.Birthday, nil
}

// AddBirthday adds u to the "birthday" field.
func (m *AppUserExtraMutation) AddBirthday(u int32) {
	if m.addbirthday != nil {
		*m.addbirthday += u
	} else {
		m.addbirthday = &u
	}
}

// AddedBirthday returns the value that was added to the "birthday" field in this mutation.
func (m *AppUserExtraMutation) AddedBirthday() (r int32, exists bool) {
	v := m.addbirthday
	if v == nil {
		return
	}
	return *v, true
}

// ResetBirthday resets all changes to the "birthday" field.
func (m *AppUserExtraMutation) ResetBirthday() {
	m.birthday = nil
	m.addbirthday = nil
}

// SetAvatar sets the "avatar" field.
func (m *AppUserExtraMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *AppUserExtraMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *AppUserExtraMutation) ResetAvatar() {
	m.avatar = nil
}

// SetOrganization sets the "organization" field.
func (m *AppUserExtraMutation) SetOrganization(s string) {
	m.organization = &s
}

// Organization returns the value of the "organization" field in the mutation.
func (m *AppUserExtraMutation) Organization() (r string, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganization returns the old "organization" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldOrganization(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganization is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganization requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganization: %w", err)
	}
	return oldValue.Organization, nil
}

// ResetOrganization resets all changes to the "organization" field.
func (m *AppUserExtraMutation) ResetOrganization() {
	m.organization = nil
}

// SetIDNumber sets the "id_number" field.
func (m *AppUserExtraMutation) SetIDNumber(s string) {
	m.id_number = &s
}

// IDNumber returns the value of the "id_number" field in the mutation.
func (m *AppUserExtraMutation) IDNumber() (r string, exists bool) {
	v := m.id_number
	if v == nil {
		return
	}
	return *v, true
}

// OldIDNumber returns the old "id_number" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldIDNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIDNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIDNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIDNumber: %w", err)
	}
	return oldValue.IDNumber, nil
}

// ResetIDNumber resets all changes to the "id_number" field.
func (m *AppUserExtraMutation) ResetIDNumber() {
	m.id_number = nil
}

// Where appends a list predicates to the AppUserExtraMutation builder.
func (m *AppUserExtraMutation) Where(ps ...predicate.AppUserExtra) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AppUserExtraMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AppUserExtra).
func (m *AppUserExtraMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppUserExtraMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, appuserextra.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appuserextra.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appuserextra.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, appuserextra.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, appuserextra.FieldUserID)
	}
	if m.username != nil {
		fields = append(fields, appuserextra.FieldUsername)
	}
	if m.first_name != nil {
		fields = append(fields, appuserextra.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, appuserextra.FieldLastName)
	}
	if m.address_fields != nil {
		fields = append(fields, appuserextra.FieldAddressFields)
	}
	if m.gender != nil {
		fields = append(fields, appuserextra.FieldGender)
	}
	if m.postal_code != nil {
		fields = append(fields, appuserextra.FieldPostalCode)
	}
	if m.age != nil {
		fields = append(fields, appuserextra.FieldAge)
	}
	if m.birthday != nil {
		fields = append(fields, appuserextra.FieldBirthday)
	}
	if m.avatar != nil {
		fields = append(fields, appuserextra.FieldAvatar)
	}
	if m.organization != nil {
		fields = append(fields, appuserextra.FieldOrganization)
	}
	if m.id_number != nil {
		fields = append(fields, appuserextra.FieldIDNumber)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppUserExtraMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appuserextra.FieldCreatedAt:
		return m.CreatedAt()
	case appuserextra.FieldUpdatedAt:
		return m.UpdatedAt()
	case appuserextra.FieldDeletedAt:
		return m.DeletedAt()
	case appuserextra.FieldAppID:
		return m.AppID()
	case appuserextra.FieldUserID:
		return m.UserID()
	case appuserextra.FieldUsername:
		return m.Username()
	case appuserextra.FieldFirstName:
		return m.FirstName()
	case appuserextra.FieldLastName:
		return m.LastName()
	case appuserextra.FieldAddressFields:
		return m.AddressFields()
	case appuserextra.FieldGender:
		return m.Gender()
	case appuserextra.FieldPostalCode:
		return m.PostalCode()
	case appuserextra.FieldAge:
		return m.Age()
	case appuserextra.FieldBirthday:
		return m.Birthday()
	case appuserextra.FieldAvatar:
		return m.Avatar()
	case appuserextra.FieldOrganization:
		return m.Organization()
	case appuserextra.FieldIDNumber:
		return m.IDNumber()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppUserExtraMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appuserextra.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appuserextra.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appuserextra.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appuserextra.FieldAppID:
		return m.OldAppID(ctx)
	case appuserextra.FieldUserID:
		return m.OldUserID(ctx)
	case appuserextra.FieldUsername:
		return m.OldUsername(ctx)
	case appuserextra.FieldFirstName:
		return m.OldFirstName(ctx)
	case appuserextra.FieldLastName:
		return m.OldLastName(ctx)
	case appuserextra.FieldAddressFields:
		return m.OldAddressFields(ctx)
	case appuserextra.FieldGender:
		return m.OldGender(ctx)
	case appuserextra.FieldPostalCode:
		return m.OldPostalCode(ctx)
	case appuserextra.FieldAge:
		return m.OldAge(ctx)
	case appuserextra.FieldBirthday:
		return m.OldBirthday(ctx)
	case appuserextra.FieldAvatar:
		return m.OldAvatar(ctx)
	case appuserextra.FieldOrganization:
		return m.OldOrganization(ctx)
	case appuserextra.FieldIDNumber:
		return m.OldIDNumber(ctx)
	}
	return nil, fmt.Errorf("unknown AppUserExtra field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppUserExtraMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appuserextra.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appuserextra.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appuserextra.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appuserextra.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appuserextra.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case appuserextra.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case appuserextra.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case appuserextra.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case appuserextra.FieldAddressFields:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressFields(v)
		return nil
	case appuserextra.FieldGender:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case appuserextra.FieldPostalCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostalCode(v)
		return nil
	case appuserextra.FieldAge:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAge(v)
		return nil
	case appuserextra.FieldBirthday:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthday(v)
		return nil
	case appuserextra.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case appuserextra.FieldOrganization:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganization(v)
		return nil
	case appuserextra.FieldIDNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIDNumber(v)
		return nil
	}
	return fmt.Errorf("unknown AppUserExtra field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppUserExtraMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, appuserextra.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, appuserextra.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, appuserextra.FieldDeletedAt)
	}
	if m.addage != nil {
		fields = append(fields, appuserextra.FieldAge)
	}
	if m.addbirthday != nil {
		fields = append(fields, appuserextra.FieldBirthday)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppUserExtraMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appuserextra.FieldCreatedAt:
		return m.AddedCreatedAt()
	case appuserextra.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case appuserextra.FieldDeletedAt:
		return m.AddedDeletedAt()
	case appuserextra.FieldAge:
		return m.AddedAge()
	case appuserextra.FieldBirthday:
		return m.AddedBirthday()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppUserExtraMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appuserextra.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case appuserextra.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case appuserextra.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case appuserextra.FieldAge:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAge(v)
		return nil
	case appuserextra.FieldBirthday:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBirthday(v)
		return nil
	}
	return fmt.Errorf("unknown AppUserExtra numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppUserExtraMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppUserExtraMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppUserExtraMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AppUserExtra nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppUserExtraMutation) ResetField(name string) error {
	switch name {
	case appuserextra.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appuserextra.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appuserextra.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appuserextra.FieldAppID:
		m.ResetAppID()
		return nil
	case appuserextra.FieldUserID:
		m.ResetUserID()
		return nil
	case appuserextra.FieldUsername:
		m.ResetUsername()
		return nil
	case appuserextra.FieldFirstName:
		m.ResetFirstName()
		return nil
	case appuserextra.FieldLastName:
		m.ResetLastName()
		return nil
	case appuserextra.FieldAddressFields:
		m.ResetAddressFields()
		return nil
	case appuserextra.FieldGender:
		m.ResetGender()
		return nil
	case appuserextra.FieldPostalCode:
		m.ResetPostalCode()
		return nil
	case appuserextra.FieldAge:
		m.ResetAge()
		return nil
	case appuserextra.FieldBirthday:
		m.ResetBirthday()
		return nil
	case appuserextra.FieldAvatar:
		m.ResetAvatar()
		return nil
	case appuserextra.FieldOrganization:
		m.ResetOrganization()
		return nil
	case appuserextra.FieldIDNumber:
		m.ResetIDNumber()
		return nil
	}
	return fmt.Errorf("unknown AppUserExtra field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppUserExtraMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppUserExtraMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppUserExtraMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppUserExtraMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppUserExtraMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppUserExtraMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppUserExtraMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppUserExtra unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppUserExtraMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppUserExtra edge %s", name)
}

// AppUserSecretMutation represents an operation that mutates the AppUserSecret nodes in the graph.
type AppUserSecretMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	app_id        *uuid.UUID
	user_id       *uuid.UUID
	password_hash *string
	salt          *string
	google_secret *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AppUserSecret, error)
	predicates    []predicate.AppUserSecret
}

var _ ent.Mutation = (*AppUserSecretMutation)(nil)

// appusersecretOption allows management of the mutation configuration using functional options.
type appusersecretOption func(*AppUserSecretMutation)

// newAppUserSecretMutation creates new mutation for the AppUserSecret entity.
func newAppUserSecretMutation(c config, op Op, opts ...appusersecretOption) *AppUserSecretMutation {
	m := &AppUserSecretMutation{
		config:        c,
		op:            op,
		typ:           TypeAppUserSecret,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppUserSecretID sets the ID field of the mutation.
func withAppUserSecretID(id uuid.UUID) appusersecretOption {
	return func(m *AppUserSecretMutation) {
		var (
			err   error
			once  sync.Once
			value *AppUserSecret
		)
		m.oldValue = func(ctx context.Context) (*AppUserSecret, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppUserSecret.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppUserSecret sets the old AppUserSecret of the mutation.
func withAppUserSecret(node *AppUserSecret) appusersecretOption {
	return func(m *AppUserSecretMutation) {
		m.oldValue = func(context.Context) (*AppUserSecret, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppUserSecretMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppUserSecretMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppUserSecret entities.
func (m *AppUserSecretMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppUserSecretMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppUserSecretMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppUserSecret.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppUserSecretMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppUserSecretMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppUserSecret entity.
// If the AppUserSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserSecretMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppUserSecretMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppUserSecretMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppUserSecretMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppUserSecretMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppUserSecretMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppUserSecret entity.
// If the AppUserSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserSecretMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppUserSecretMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppUserSecretMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppUserSecretMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppUserSecretMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppUserSecretMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppUserSecret entity.
// If the AppUserSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserSecretMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppUserSecretMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppUserSecretMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppUserSecretMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *AppUserSecretMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppUserSecretMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppUserSecret entity.
// If the AppUserSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserSecretMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppUserSecretMutation) ResetAppID() {
	m.app_id = nil
}

// SetUserID sets the "user_id" field.
func (m *AppUserSecretMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AppUserSecretMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AppUserSecret entity.
// If the AppUserSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserSecretMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AppUserSecretMutation) ResetUserID() {
	m.user_id = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *AppUserSecretMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *AppUserSecretMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the AppUserSecret entity.
// If the AppUserSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserSecretMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *AppUserSecretMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetSalt sets the "salt" field.
func (m *AppUserSecretMutation) SetSalt(s string) {
	m.salt = &s
}

// Salt returns the value of the "salt" field in the mutation.
func (m *AppUserSecretMutation) Salt() (r string, exists bool) {
	v := m.salt
	if v == nil {
		return
	}
	return *v, true
}

// OldSalt returns the old "salt" field's value of the AppUserSecret entity.
// If the AppUserSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserSecretMutation) OldSalt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalt: %w", err)
	}
	return oldValue.Salt, nil
}

// ResetSalt resets all changes to the "salt" field.
func (m *AppUserSecretMutation) ResetSalt() {
	m.salt = nil
}

// SetGoogleSecret sets the "google_secret" field.
func (m *AppUserSecretMutation) SetGoogleSecret(s string) {
	m.google_secret = &s
}

// GoogleSecret returns the value of the "google_secret" field in the mutation.
func (m *AppUserSecretMutation) GoogleSecret() (r string, exists bool) {
	v := m.google_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldGoogleSecret returns the old "google_secret" field's value of the AppUserSecret entity.
// If the AppUserSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserSecretMutation) OldGoogleSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoogleSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoogleSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoogleSecret: %w", err)
	}
	return oldValue.GoogleSecret, nil
}

// ResetGoogleSecret resets all changes to the "google_secret" field.
func (m *AppUserSecretMutation) ResetGoogleSecret() {
	m.google_secret = nil
}

// Where appends a list predicates to the AppUserSecretMutation builder.
func (m *AppUserSecretMutation) Where(ps ...predicate.AppUserSecret) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AppUserSecretMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AppUserSecret).
func (m *AppUserSecretMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppUserSecretMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, appusersecret.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appusersecret.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appusersecret.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, appusersecret.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, appusersecret.FieldUserID)
	}
	if m.password_hash != nil {
		fields = append(fields, appusersecret.FieldPasswordHash)
	}
	if m.salt != nil {
		fields = append(fields, appusersecret.FieldSalt)
	}
	if m.google_secret != nil {
		fields = append(fields, appusersecret.FieldGoogleSecret)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppUserSecretMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appusersecret.FieldCreatedAt:
		return m.CreatedAt()
	case appusersecret.FieldUpdatedAt:
		return m.UpdatedAt()
	case appusersecret.FieldDeletedAt:
		return m.DeletedAt()
	case appusersecret.FieldAppID:
		return m.AppID()
	case appusersecret.FieldUserID:
		return m.UserID()
	case appusersecret.FieldPasswordHash:
		return m.PasswordHash()
	case appusersecret.FieldSalt:
		return m.Salt()
	case appusersecret.FieldGoogleSecret:
		return m.GoogleSecret()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppUserSecretMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appusersecret.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appusersecret.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appusersecret.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appusersecret.FieldAppID:
		return m.OldAppID(ctx)
	case appusersecret.FieldUserID:
		return m.OldUserID(ctx)
	case appusersecret.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case appusersecret.FieldSalt:
		return m.OldSalt(ctx)
	case appusersecret.FieldGoogleSecret:
		return m.OldGoogleSecret(ctx)
	}
	return nil, fmt.Errorf("unknown AppUserSecret field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppUserSecretMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appusersecret.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appusersecret.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appusersecret.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appusersecret.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appusersecret.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case appusersecret.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case appusersecret.FieldSalt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalt(v)
		return nil
	case appusersecret.FieldGoogleSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoogleSecret(v)
		return nil
	}
	return fmt.Errorf("unknown AppUserSecret field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppUserSecretMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, appusersecret.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, appusersecret.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, appusersecret.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppUserSecretMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appusersecret.FieldCreatedAt:
		return m.AddedCreatedAt()
	case appusersecret.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case appusersecret.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppUserSecretMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appusersecret.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case appusersecret.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case appusersecret.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppUserSecret numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppUserSecretMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppUserSecretMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppUserSecretMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AppUserSecret nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppUserSecretMutation) ResetField(name string) error {
	switch name {
	case appusersecret.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appusersecret.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appusersecret.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appusersecret.FieldAppID:
		m.ResetAppID()
		return nil
	case appusersecret.FieldUserID:
		m.ResetUserID()
		return nil
	case appusersecret.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case appusersecret.FieldSalt:
		m.ResetSalt()
		return nil
	case appusersecret.FieldGoogleSecret:
		m.ResetGoogleSecret()
		return nil
	}
	return fmt.Errorf("unknown AppUserSecret field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppUserSecretMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppUserSecretMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppUserSecretMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppUserSecretMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppUserSecretMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppUserSecretMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppUserSecretMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppUserSecret unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppUserSecretMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppUserSecret edge %s", name)
}

// AppUserThirdPartyMutation represents an operation that mutates the AppUserThirdParty nodes in the graph.
type AppUserThirdPartyMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *uint32
	addcreated_at        *int32
	updated_at           *uint32
	addupdated_at        *int32
	deleted_at           *uint32
	adddeleted_at        *int32
	app_id               *uuid.UUID
	user_id              *uuid.UUID
	third_party_user_id  *string
	third_party_id       *string
	third_party_username *string
	third_party_avatar   *string
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*AppUserThirdParty, error)
	predicates           []predicate.AppUserThirdParty
}

var _ ent.Mutation = (*AppUserThirdPartyMutation)(nil)

// appuserthirdpartyOption allows management of the mutation configuration using functional options.
type appuserthirdpartyOption func(*AppUserThirdPartyMutation)

// newAppUserThirdPartyMutation creates new mutation for the AppUserThirdParty entity.
func newAppUserThirdPartyMutation(c config, op Op, opts ...appuserthirdpartyOption) *AppUserThirdPartyMutation {
	m := &AppUserThirdPartyMutation{
		config:        c,
		op:            op,
		typ:           TypeAppUserThirdParty,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppUserThirdPartyID sets the ID field of the mutation.
func withAppUserThirdPartyID(id uuid.UUID) appuserthirdpartyOption {
	return func(m *AppUserThirdPartyMutation) {
		var (
			err   error
			once  sync.Once
			value *AppUserThirdParty
		)
		m.oldValue = func(ctx context.Context) (*AppUserThirdParty, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppUserThirdParty.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppUserThirdParty sets the old AppUserThirdParty of the mutation.
func withAppUserThirdParty(node *AppUserThirdParty) appuserthirdpartyOption {
	return func(m *AppUserThirdPartyMutation) {
		m.oldValue = func(context.Context) (*AppUserThirdParty, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppUserThirdPartyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppUserThirdPartyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppUserThirdParty entities.
func (m *AppUserThirdPartyMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppUserThirdPartyMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppUserThirdPartyMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppUserThirdParty.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppUserThirdPartyMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppUserThirdPartyMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppUserThirdParty entity.
// If the AppUserThirdParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserThirdPartyMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppUserThirdPartyMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppUserThirdPartyMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppUserThirdPartyMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppUserThirdPartyMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppUserThirdPartyMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppUserThirdParty entity.
// If the AppUserThirdParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserThirdPartyMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppUserThirdPartyMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppUserThirdPartyMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppUserThirdPartyMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppUserThirdPartyMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppUserThirdPartyMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppUserThirdParty entity.
// If the AppUserThirdParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserThirdPartyMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppUserThirdPartyMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppUserThirdPartyMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppUserThirdPartyMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *AppUserThirdPartyMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppUserThirdPartyMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppUserThirdParty entity.
// If the AppUserThirdParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserThirdPartyMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *AppUserThirdPartyMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[appuserthirdparty.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *AppUserThirdPartyMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[appuserthirdparty.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppUserThirdPartyMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, appuserthirdparty.FieldAppID)
}

// SetUserID sets the "user_id" field.
func (m *AppUserThirdPartyMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AppUserThirdPartyMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AppUserThirdParty entity.
// If the AppUserThirdParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserThirdPartyMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *AppUserThirdPartyMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[appuserthirdparty.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *AppUserThirdPartyMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[appuserthirdparty.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AppUserThirdPartyMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, appuserthirdparty.FieldUserID)
}

// SetThirdPartyUserID sets the "third_party_user_id" field.
func (m *AppUserThirdPartyMutation) SetThirdPartyUserID(s string) {
	m.third_party_user_id = &s
}

// ThirdPartyUserID returns the value of the "third_party_user_id" field in the mutation.
func (m *AppUserThirdPartyMutation) ThirdPartyUserID() (r string, exists bool) {
	v := m.third_party_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldThirdPartyUserID returns the old "third_party_user_id" field's value of the AppUserThirdParty entity.
// If the AppUserThirdParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserThirdPartyMutation) OldThirdPartyUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThirdPartyUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThirdPartyUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThirdPartyUserID: %w", err)
	}
	return oldValue.ThirdPartyUserID, nil
}

// ClearThirdPartyUserID clears the value of the "third_party_user_id" field.
func (m *AppUserThirdPartyMutation) ClearThirdPartyUserID() {
	m.third_party_user_id = nil
	m.clearedFields[appuserthirdparty.FieldThirdPartyUserID] = struct{}{}
}

// ThirdPartyUserIDCleared returns if the "third_party_user_id" field was cleared in this mutation.
func (m *AppUserThirdPartyMutation) ThirdPartyUserIDCleared() bool {
	_, ok := m.clearedFields[appuserthirdparty.FieldThirdPartyUserID]
	return ok
}

// ResetThirdPartyUserID resets all changes to the "third_party_user_id" field.
func (m *AppUserThirdPartyMutation) ResetThirdPartyUserID() {
	m.third_party_user_id = nil
	delete(m.clearedFields, appuserthirdparty.FieldThirdPartyUserID)
}

// SetThirdPartyID sets the "third_party_id" field.
func (m *AppUserThirdPartyMutation) SetThirdPartyID(s string) {
	m.third_party_id = &s
}

// ThirdPartyID returns the value of the "third_party_id" field in the mutation.
func (m *AppUserThirdPartyMutation) ThirdPartyID() (r string, exists bool) {
	v := m.third_party_id
	if v == nil {
		return
	}
	return *v, true
}

// OldThirdPartyID returns the old "third_party_id" field's value of the AppUserThirdParty entity.
// If the AppUserThirdParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserThirdPartyMutation) OldThirdPartyID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThirdPartyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThirdPartyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThirdPartyID: %w", err)
	}
	return oldValue.ThirdPartyID, nil
}

// ClearThirdPartyID clears the value of the "third_party_id" field.
func (m *AppUserThirdPartyMutation) ClearThirdPartyID() {
	m.third_party_id = nil
	m.clearedFields[appuserthirdparty.FieldThirdPartyID] = struct{}{}
}

// ThirdPartyIDCleared returns if the "third_party_id" field was cleared in this mutation.
func (m *AppUserThirdPartyMutation) ThirdPartyIDCleared() bool {
	_, ok := m.clearedFields[appuserthirdparty.FieldThirdPartyID]
	return ok
}

// ResetThirdPartyID resets all changes to the "third_party_id" field.
func (m *AppUserThirdPartyMutation) ResetThirdPartyID() {
	m.third_party_id = nil
	delete(m.clearedFields, appuserthirdparty.FieldThirdPartyID)
}

// SetThirdPartyUsername sets the "third_party_username" field.
func (m *AppUserThirdPartyMutation) SetThirdPartyUsername(s string) {
	m.third_party_username = &s
}

// ThirdPartyUsername returns the value of the "third_party_username" field in the mutation.
func (m *AppUserThirdPartyMutation) ThirdPartyUsername() (r string, exists bool) {
	v := m.third_party_username
	if v == nil {
		return
	}
	return *v, true
}

// OldThirdPartyUsername returns the old "third_party_username" field's value of the AppUserThirdParty entity.
// If the AppUserThirdParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserThirdPartyMutation) OldThirdPartyUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThirdPartyUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThirdPartyUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThirdPartyUsername: %w", err)
	}
	return oldValue.ThirdPartyUsername, nil
}

// ClearThirdPartyUsername clears the value of the "third_party_username" field.
func (m *AppUserThirdPartyMutation) ClearThirdPartyUsername() {
	m.third_party_username = nil
	m.clearedFields[appuserthirdparty.FieldThirdPartyUsername] = struct{}{}
}

// ThirdPartyUsernameCleared returns if the "third_party_username" field was cleared in this mutation.
func (m *AppUserThirdPartyMutation) ThirdPartyUsernameCleared() bool {
	_, ok := m.clearedFields[appuserthirdparty.FieldThirdPartyUsername]
	return ok
}

// ResetThirdPartyUsername resets all changes to the "third_party_username" field.
func (m *AppUserThirdPartyMutation) ResetThirdPartyUsername() {
	m.third_party_username = nil
	delete(m.clearedFields, appuserthirdparty.FieldThirdPartyUsername)
}

// SetThirdPartyAvatar sets the "third_party_avatar" field.
func (m *AppUserThirdPartyMutation) SetThirdPartyAvatar(s string) {
	m.third_party_avatar = &s
}

// ThirdPartyAvatar returns the value of the "third_party_avatar" field in the mutation.
func (m *AppUserThirdPartyMutation) ThirdPartyAvatar() (r string, exists bool) {
	v := m.third_party_avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldThirdPartyAvatar returns the old "third_party_avatar" field's value of the AppUserThirdParty entity.
// If the AppUserThirdParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserThirdPartyMutation) OldThirdPartyAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThirdPartyAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThirdPartyAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThirdPartyAvatar: %w", err)
	}
	return oldValue.ThirdPartyAvatar, nil
}

// ClearThirdPartyAvatar clears the value of the "third_party_avatar" field.
func (m *AppUserThirdPartyMutation) ClearThirdPartyAvatar() {
	m.third_party_avatar = nil
	m.clearedFields[appuserthirdparty.FieldThirdPartyAvatar] = struct{}{}
}

// ThirdPartyAvatarCleared returns if the "third_party_avatar" field was cleared in this mutation.
func (m *AppUserThirdPartyMutation) ThirdPartyAvatarCleared() bool {
	_, ok := m.clearedFields[appuserthirdparty.FieldThirdPartyAvatar]
	return ok
}

// ResetThirdPartyAvatar resets all changes to the "third_party_avatar" field.
func (m *AppUserThirdPartyMutation) ResetThirdPartyAvatar() {
	m.third_party_avatar = nil
	delete(m.clearedFields, appuserthirdparty.FieldThirdPartyAvatar)
}

// Where appends a list predicates to the AppUserThirdPartyMutation builder.
func (m *AppUserThirdPartyMutation) Where(ps ...predicate.AppUserThirdParty) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AppUserThirdPartyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AppUserThirdParty).
func (m *AppUserThirdPartyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppUserThirdPartyMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, appuserthirdparty.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appuserthirdparty.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appuserthirdparty.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, appuserthirdparty.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, appuserthirdparty.FieldUserID)
	}
	if m.third_party_user_id != nil {
		fields = append(fields, appuserthirdparty.FieldThirdPartyUserID)
	}
	if m.third_party_id != nil {
		fields = append(fields, appuserthirdparty.FieldThirdPartyID)
	}
	if m.third_party_username != nil {
		fields = append(fields, appuserthirdparty.FieldThirdPartyUsername)
	}
	if m.third_party_avatar != nil {
		fields = append(fields, appuserthirdparty.FieldThirdPartyAvatar)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppUserThirdPartyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appuserthirdparty.FieldCreatedAt:
		return m.CreatedAt()
	case appuserthirdparty.FieldUpdatedAt:
		return m.UpdatedAt()
	case appuserthirdparty.FieldDeletedAt:
		return m.DeletedAt()
	case appuserthirdparty.FieldAppID:
		return m.AppID()
	case appuserthirdparty.FieldUserID:
		return m.UserID()
	case appuserthirdparty.FieldThirdPartyUserID:
		return m.ThirdPartyUserID()
	case appuserthirdparty.FieldThirdPartyID:
		return m.ThirdPartyID()
	case appuserthirdparty.FieldThirdPartyUsername:
		return m.ThirdPartyUsername()
	case appuserthirdparty.FieldThirdPartyAvatar:
		return m.ThirdPartyAvatar()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppUserThirdPartyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appuserthirdparty.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appuserthirdparty.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appuserthirdparty.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appuserthirdparty.FieldAppID:
		return m.OldAppID(ctx)
	case appuserthirdparty.FieldUserID:
		return m.OldUserID(ctx)
	case appuserthirdparty.FieldThirdPartyUserID:
		return m.OldThirdPartyUserID(ctx)
	case appuserthirdparty.FieldThirdPartyID:
		return m.OldThirdPartyID(ctx)
	case appuserthirdparty.FieldThirdPartyUsername:
		return m.OldThirdPartyUsername(ctx)
	case appuserthirdparty.FieldThirdPartyAvatar:
		return m.OldThirdPartyAvatar(ctx)
	}
	return nil, fmt.Errorf("unknown AppUserThirdParty field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppUserThirdPartyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appuserthirdparty.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appuserthirdparty.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appuserthirdparty.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appuserthirdparty.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appuserthirdparty.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case appuserthirdparty.FieldThirdPartyUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThirdPartyUserID(v)
		return nil
	case appuserthirdparty.FieldThirdPartyID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThirdPartyID(v)
		return nil
	case appuserthirdparty.FieldThirdPartyUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThirdPartyUsername(v)
		return nil
	case appuserthirdparty.FieldThirdPartyAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThirdPartyAvatar(v)
		return nil
	}
	return fmt.Errorf("unknown AppUserThirdParty field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppUserThirdPartyMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, appuserthirdparty.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, appuserthirdparty.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, appuserthirdparty.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppUserThirdPartyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appuserthirdparty.FieldCreatedAt:
		return m.AddedCreatedAt()
	case appuserthirdparty.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case appuserthirdparty.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppUserThirdPartyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appuserthirdparty.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case appuserthirdparty.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case appuserthirdparty.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppUserThirdParty numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppUserThirdPartyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appuserthirdparty.FieldAppID) {
		fields = append(fields, appuserthirdparty.FieldAppID)
	}
	if m.FieldCleared(appuserthirdparty.FieldUserID) {
		fields = append(fields, appuserthirdparty.FieldUserID)
	}
	if m.FieldCleared(appuserthirdparty.FieldThirdPartyUserID) {
		fields = append(fields, appuserthirdparty.FieldThirdPartyUserID)
	}
	if m.FieldCleared(appuserthirdparty.FieldThirdPartyID) {
		fields = append(fields, appuserthirdparty.FieldThirdPartyID)
	}
	if m.FieldCleared(appuserthirdparty.FieldThirdPartyUsername) {
		fields = append(fields, appuserthirdparty.FieldThirdPartyUsername)
	}
	if m.FieldCleared(appuserthirdparty.FieldThirdPartyAvatar) {
		fields = append(fields, appuserthirdparty.FieldThirdPartyAvatar)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppUserThirdPartyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppUserThirdPartyMutation) ClearField(name string) error {
	switch name {
	case appuserthirdparty.FieldAppID:
		m.ClearAppID()
		return nil
	case appuserthirdparty.FieldUserID:
		m.ClearUserID()
		return nil
	case appuserthirdparty.FieldThirdPartyUserID:
		m.ClearThirdPartyUserID()
		return nil
	case appuserthirdparty.FieldThirdPartyID:
		m.ClearThirdPartyID()
		return nil
	case appuserthirdparty.FieldThirdPartyUsername:
		m.ClearThirdPartyUsername()
		return nil
	case appuserthirdparty.FieldThirdPartyAvatar:
		m.ClearThirdPartyAvatar()
		return nil
	}
	return fmt.Errorf("unknown AppUserThirdParty nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppUserThirdPartyMutation) ResetField(name string) error {
	switch name {
	case appuserthirdparty.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appuserthirdparty.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appuserthirdparty.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appuserthirdparty.FieldAppID:
		m.ResetAppID()
		return nil
	case appuserthirdparty.FieldUserID:
		m.ResetUserID()
		return nil
	case appuserthirdparty.FieldThirdPartyUserID:
		m.ResetThirdPartyUserID()
		return nil
	case appuserthirdparty.FieldThirdPartyID:
		m.ResetThirdPartyID()
		return nil
	case appuserthirdparty.FieldThirdPartyUsername:
		m.ResetThirdPartyUsername()
		return nil
	case appuserthirdparty.FieldThirdPartyAvatar:
		m.ResetThirdPartyAvatar()
		return nil
	}
	return fmt.Errorf("unknown AppUserThirdParty field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppUserThirdPartyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppUserThirdPartyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppUserThirdPartyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppUserThirdPartyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppUserThirdPartyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppUserThirdPartyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppUserThirdPartyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppUserThirdParty unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppUserThirdPartyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppUserThirdParty edge %s", name)
}

// AuthMutation represents an operation that mutates the Auth nodes in the graph.
type AuthMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	app_id        *uuid.UUID
	role_id       *uuid.UUID
	user_id       *uuid.UUID
	resource      *string
	method        *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Auth, error)
	predicates    []predicate.Auth
}

var _ ent.Mutation = (*AuthMutation)(nil)

// authOption allows management of the mutation configuration using functional options.
type authOption func(*AuthMutation)

// newAuthMutation creates new mutation for the Auth entity.
func newAuthMutation(c config, op Op, opts ...authOption) *AuthMutation {
	m := &AuthMutation{
		config:        c,
		op:            op,
		typ:           TypeAuth,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthID sets the ID field of the mutation.
func withAuthID(id uuid.UUID) authOption {
	return func(m *AuthMutation) {
		var (
			err   error
			once  sync.Once
			value *Auth
		)
		m.oldValue = func(ctx context.Context) (*Auth, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Auth.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuth sets the old Auth of the mutation.
func withAuth(node *Auth) authOption {
	return func(m *AuthMutation) {
		m.oldValue = func(context.Context) (*Auth, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Auth entities.
func (m *AuthMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuthMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Auth.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AuthMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AuthMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AuthMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AuthMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AuthMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AuthMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AuthMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AuthMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AuthMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AuthMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AuthMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AuthMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AuthMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AuthMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AuthMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *AuthMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AuthMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *AuthMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[auth.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *AuthMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[auth.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AuthMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, auth.FieldAppID)
}

// SetRoleID sets the "role_id" field.
func (m *AuthMutation) SetRoleID(u uuid.UUID) {
	m.role_id = &u
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *AuthMutation) RoleID() (r uuid.UUID, exists bool) {
	v := m.role_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldRoleID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ClearRoleID clears the value of the "role_id" field.
func (m *AuthMutation) ClearRoleID() {
	m.role_id = nil
	m.clearedFields[auth.FieldRoleID] = struct{}{}
}

// RoleIDCleared returns if the "role_id" field was cleared in this mutation.
func (m *AuthMutation) RoleIDCleared() bool {
	_, ok := m.clearedFields[auth.FieldRoleID]
	return ok
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *AuthMutation) ResetRoleID() {
	m.role_id = nil
	delete(m.clearedFields, auth.FieldRoleID)
}

// SetUserID sets the "user_id" field.
func (m *AuthMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AuthMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *AuthMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[auth.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *AuthMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[auth.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AuthMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, auth.FieldUserID)
}

// SetResource sets the "resource" field.
func (m *AuthMutation) SetResource(s string) {
	m.resource = &s
}

// Resource returns the value of the "resource" field in the mutation.
func (m *AuthMutation) Resource() (r string, exists bool) {
	v := m.resource
	if v == nil {
		return
	}
	return *v, true
}

// OldResource returns the old "resource" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldResource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResource: %w", err)
	}
	return oldValue.Resource, nil
}

// ClearResource clears the value of the "resource" field.
func (m *AuthMutation) ClearResource() {
	m.resource = nil
	m.clearedFields[auth.FieldResource] = struct{}{}
}

// ResourceCleared returns if the "resource" field was cleared in this mutation.
func (m *AuthMutation) ResourceCleared() bool {
	_, ok := m.clearedFields[auth.FieldResource]
	return ok
}

// ResetResource resets all changes to the "resource" field.
func (m *AuthMutation) ResetResource() {
	m.resource = nil
	delete(m.clearedFields, auth.FieldResource)
}

// SetMethod sets the "method" field.
func (m *AuthMutation) SetMethod(s string) {
	m.method = &s
}

// Method returns the value of the "method" field in the mutation.
func (m *AuthMutation) Method() (r string, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ClearMethod clears the value of the "method" field.
func (m *AuthMutation) ClearMethod() {
	m.method = nil
	m.clearedFields[auth.FieldMethod] = struct{}{}
}

// MethodCleared returns if the "method" field was cleared in this mutation.
func (m *AuthMutation) MethodCleared() bool {
	_, ok := m.clearedFields[auth.FieldMethod]
	return ok
}

// ResetMethod resets all changes to the "method" field.
func (m *AuthMutation) ResetMethod() {
	m.method = nil
	delete(m.clearedFields, auth.FieldMethod)
}

// Where appends a list predicates to the AuthMutation builder.
func (m *AuthMutation) Where(ps ...predicate.Auth) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AuthMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Auth).
func (m *AuthMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, auth.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, auth.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, auth.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, auth.FieldAppID)
	}
	if m.role_id != nil {
		fields = append(fields, auth.FieldRoleID)
	}
	if m.user_id != nil {
		fields = append(fields, auth.FieldUserID)
	}
	if m.resource != nil {
		fields = append(fields, auth.FieldResource)
	}
	if m.method != nil {
		fields = append(fields, auth.FieldMethod)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case auth.FieldCreatedAt:
		return m.CreatedAt()
	case auth.FieldUpdatedAt:
		return m.UpdatedAt()
	case auth.FieldDeletedAt:
		return m.DeletedAt()
	case auth.FieldAppID:
		return m.AppID()
	case auth.FieldRoleID:
		return m.RoleID()
	case auth.FieldUserID:
		return m.UserID()
	case auth.FieldResource:
		return m.Resource()
	case auth.FieldMethod:
		return m.Method()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case auth.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case auth.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case auth.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case auth.FieldAppID:
		return m.OldAppID(ctx)
	case auth.FieldRoleID:
		return m.OldRoleID(ctx)
	case auth.FieldUserID:
		return m.OldUserID(ctx)
	case auth.FieldResource:
		return m.OldResource(ctx)
	case auth.FieldMethod:
		return m.OldMethod(ctx)
	}
	return nil, fmt.Errorf("unknown Auth field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthMutation) SetField(name string, value ent.Value) error {
	switch name {
	case auth.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case auth.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case auth.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case auth.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case auth.FieldRoleID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case auth.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case auth.FieldResource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResource(v)
		return nil
	case auth.FieldMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	}
	return fmt.Errorf("unknown Auth field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, auth.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, auth.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, auth.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case auth.FieldCreatedAt:
		return m.AddedCreatedAt()
	case auth.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case auth.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthMutation) AddField(name string, value ent.Value) error {
	switch name {
	case auth.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case auth.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case auth.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Auth numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(auth.FieldAppID) {
		fields = append(fields, auth.FieldAppID)
	}
	if m.FieldCleared(auth.FieldRoleID) {
		fields = append(fields, auth.FieldRoleID)
	}
	if m.FieldCleared(auth.FieldUserID) {
		fields = append(fields, auth.FieldUserID)
	}
	if m.FieldCleared(auth.FieldResource) {
		fields = append(fields, auth.FieldResource)
	}
	if m.FieldCleared(auth.FieldMethod) {
		fields = append(fields, auth.FieldMethod)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthMutation) ClearField(name string) error {
	switch name {
	case auth.FieldAppID:
		m.ClearAppID()
		return nil
	case auth.FieldRoleID:
		m.ClearRoleID()
		return nil
	case auth.FieldUserID:
		m.ClearUserID()
		return nil
	case auth.FieldResource:
		m.ClearResource()
		return nil
	case auth.FieldMethod:
		m.ClearMethod()
		return nil
	}
	return fmt.Errorf("unknown Auth nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthMutation) ResetField(name string) error {
	switch name {
	case auth.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case auth.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case auth.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case auth.FieldAppID:
		m.ResetAppID()
		return nil
	case auth.FieldRoleID:
		m.ResetRoleID()
		return nil
	case auth.FieldUserID:
		m.ResetUserID()
		return nil
	case auth.FieldResource:
		m.ResetResource()
		return nil
	case auth.FieldMethod:
		m.ResetMethod()
		return nil
	}
	return fmt.Errorf("unknown Auth field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Auth unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Auth edge %s", name)
}

// AuthHistoryMutation represents an operation that mutates the AuthHistory nodes in the graph.
type AuthHistoryMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	app_id        *uuid.UUID
	user_id       *uuid.UUID
	resource      *string
	method        *string
	allowed       *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AuthHistory, error)
	predicates    []predicate.AuthHistory
}

var _ ent.Mutation = (*AuthHistoryMutation)(nil)

// authhistoryOption allows management of the mutation configuration using functional options.
type authhistoryOption func(*AuthHistoryMutation)

// newAuthHistoryMutation creates new mutation for the AuthHistory entity.
func newAuthHistoryMutation(c config, op Op, opts ...authhistoryOption) *AuthHistoryMutation {
	m := &AuthHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthHistoryID sets the ID field of the mutation.
func withAuthHistoryID(id uuid.UUID) authhistoryOption {
	return func(m *AuthHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *AuthHistory
		)
		m.oldValue = func(ctx context.Context) (*AuthHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuthHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthHistory sets the old AuthHistory of the mutation.
func withAuthHistory(node *AuthHistory) authhistoryOption {
	return func(m *AuthHistoryMutation) {
		m.oldValue = func(context.Context) (*AuthHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuthHistory entities.
func (m *AuthHistoryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthHistoryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuthHistoryMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuthHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AuthHistoryMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AuthHistoryMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AuthHistory entity.
// If the AuthHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthHistoryMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AuthHistoryMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AuthHistoryMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AuthHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AuthHistoryMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AuthHistoryMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AuthHistory entity.
// If the AuthHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthHistoryMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AuthHistoryMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AuthHistoryMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AuthHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AuthHistoryMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AuthHistoryMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AuthHistory entity.
// If the AuthHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthHistoryMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AuthHistoryMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AuthHistoryMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AuthHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *AuthHistoryMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AuthHistoryMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AuthHistory entity.
// If the AuthHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthHistoryMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *AuthHistoryMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[authhistory.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *AuthHistoryMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[authhistory.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AuthHistoryMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, authhistory.FieldAppID)
}

// SetUserID sets the "user_id" field.
func (m *AuthHistoryMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AuthHistoryMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AuthHistory entity.
// If the AuthHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthHistoryMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *AuthHistoryMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[authhistory.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *AuthHistoryMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[authhistory.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AuthHistoryMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, authhistory.FieldUserID)
}

// SetResource sets the "resource" field.
func (m *AuthHistoryMutation) SetResource(s string) {
	m.resource = &s
}

// Resource returns the value of the "resource" field in the mutation.
func (m *AuthHistoryMutation) Resource() (r string, exists bool) {
	v := m.resource
	if v == nil {
		return
	}
	return *v, true
}

// OldResource returns the old "resource" field's value of the AuthHistory entity.
// If the AuthHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthHistoryMutation) OldResource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResource: %w", err)
	}
	return oldValue.Resource, nil
}

// ClearResource clears the value of the "resource" field.
func (m *AuthHistoryMutation) ClearResource() {
	m.resource = nil
	m.clearedFields[authhistory.FieldResource] = struct{}{}
}

// ResourceCleared returns if the "resource" field was cleared in this mutation.
func (m *AuthHistoryMutation) ResourceCleared() bool {
	_, ok := m.clearedFields[authhistory.FieldResource]
	return ok
}

// ResetResource resets all changes to the "resource" field.
func (m *AuthHistoryMutation) ResetResource() {
	m.resource = nil
	delete(m.clearedFields, authhistory.FieldResource)
}

// SetMethod sets the "method" field.
func (m *AuthHistoryMutation) SetMethod(s string) {
	m.method = &s
}

// Method returns the value of the "method" field in the mutation.
func (m *AuthHistoryMutation) Method() (r string, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the AuthHistory entity.
// If the AuthHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthHistoryMutation) OldMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ClearMethod clears the value of the "method" field.
func (m *AuthHistoryMutation) ClearMethod() {
	m.method = nil
	m.clearedFields[authhistory.FieldMethod] = struct{}{}
}

// MethodCleared returns if the "method" field was cleared in this mutation.
func (m *AuthHistoryMutation) MethodCleared() bool {
	_, ok := m.clearedFields[authhistory.FieldMethod]
	return ok
}

// ResetMethod resets all changes to the "method" field.
func (m *AuthHistoryMutation) ResetMethod() {
	m.method = nil
	delete(m.clearedFields, authhistory.FieldMethod)
}

// SetAllowed sets the "allowed" field.
func (m *AuthHistoryMutation) SetAllowed(b bool) {
	m.allowed = &b
}

// Allowed returns the value of the "allowed" field in the mutation.
func (m *AuthHistoryMutation) Allowed() (r bool, exists bool) {
	v := m.allowed
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowed returns the old "allowed" field's value of the AuthHistory entity.
// If the AuthHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthHistoryMutation) OldAllowed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowed: %w", err)
	}
	return oldValue.Allowed, nil
}

// ClearAllowed clears the value of the "allowed" field.
func (m *AuthHistoryMutation) ClearAllowed() {
	m.allowed = nil
	m.clearedFields[authhistory.FieldAllowed] = struct{}{}
}

// AllowedCleared returns if the "allowed" field was cleared in this mutation.
func (m *AuthHistoryMutation) AllowedCleared() bool {
	_, ok := m.clearedFields[authhistory.FieldAllowed]
	return ok
}

// ResetAllowed resets all changes to the "allowed" field.
func (m *AuthHistoryMutation) ResetAllowed() {
	m.allowed = nil
	delete(m.clearedFields, authhistory.FieldAllowed)
}

// Where appends a list predicates to the AuthHistoryMutation builder.
func (m *AuthHistoryMutation) Where(ps ...predicate.AuthHistory) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AuthHistoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AuthHistory).
func (m *AuthHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthHistoryMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, authhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, authhistory.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, authhistory.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, authhistory.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, authhistory.FieldUserID)
	}
	if m.resource != nil {
		fields = append(fields, authhistory.FieldResource)
	}
	if m.method != nil {
		fields = append(fields, authhistory.FieldMethod)
	}
	if m.allowed != nil {
		fields = append(fields, authhistory.FieldAllowed)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case authhistory.FieldCreatedAt:
		return m.CreatedAt()
	case authhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case authhistory.FieldDeletedAt:
		return m.DeletedAt()
	case authhistory.FieldAppID:
		return m.AppID()
	case authhistory.FieldUserID:
		return m.UserID()
	case authhistory.FieldResource:
		return m.Resource()
	case authhistory.FieldMethod:
		return m.Method()
	case authhistory.FieldAllowed:
		return m.Allowed()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case authhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case authhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case authhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case authhistory.FieldAppID:
		return m.OldAppID(ctx)
	case authhistory.FieldUserID:
		return m.OldUserID(ctx)
	case authhistory.FieldResource:
		return m.OldResource(ctx)
	case authhistory.FieldMethod:
		return m.OldMethod(ctx)
	case authhistory.FieldAllowed:
		return m.OldAllowed(ctx)
	}
	return nil, fmt.Errorf("unknown AuthHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case authhistory.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case authhistory.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case authhistory.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case authhistory.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case authhistory.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case authhistory.FieldResource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResource(v)
		return nil
	case authhistory.FieldMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	case authhistory.FieldAllowed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowed(v)
		return nil
	}
	return fmt.Errorf("unknown AuthHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthHistoryMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, authhistory.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, authhistory.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, authhistory.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthHistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case authhistory.FieldCreatedAt:
		return m.AddedCreatedAt()
	case authhistory.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case authhistory.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case authhistory.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case authhistory.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case authhistory.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AuthHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(authhistory.FieldAppID) {
		fields = append(fields, authhistory.FieldAppID)
	}
	if m.FieldCleared(authhistory.FieldUserID) {
		fields = append(fields, authhistory.FieldUserID)
	}
	if m.FieldCleared(authhistory.FieldResource) {
		fields = append(fields, authhistory.FieldResource)
	}
	if m.FieldCleared(authhistory.FieldMethod) {
		fields = append(fields, authhistory.FieldMethod)
	}
	if m.FieldCleared(authhistory.FieldAllowed) {
		fields = append(fields, authhistory.FieldAllowed)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthHistoryMutation) ClearField(name string) error {
	switch name {
	case authhistory.FieldAppID:
		m.ClearAppID()
		return nil
	case authhistory.FieldUserID:
		m.ClearUserID()
		return nil
	case authhistory.FieldResource:
		m.ClearResource()
		return nil
	case authhistory.FieldMethod:
		m.ClearMethod()
		return nil
	case authhistory.FieldAllowed:
		m.ClearAllowed()
		return nil
	}
	return fmt.Errorf("unknown AuthHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthHistoryMutation) ResetField(name string) error {
	switch name {
	case authhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case authhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case authhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case authhistory.FieldAppID:
		m.ResetAppID()
		return nil
	case authhistory.FieldUserID:
		m.ResetUserID()
		return nil
	case authhistory.FieldResource:
		m.ResetResource()
		return nil
	case authhistory.FieldMethod:
		m.ResetMethod()
		return nil
	case authhistory.FieldAllowed:
		m.ResetAllowed()
		return nil
	}
	return fmt.Errorf("unknown AuthHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AuthHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AuthHistory edge %s", name)
}

// BanAppMutation represents an operation that mutates the BanApp nodes in the graph.
type BanAppMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	app_id        *uuid.UUID
	message       *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*BanApp, error)
	predicates    []predicate.BanApp
}

var _ ent.Mutation = (*BanAppMutation)(nil)

// banappOption allows management of the mutation configuration using functional options.
type banappOption func(*BanAppMutation)

// newBanAppMutation creates new mutation for the BanApp entity.
func newBanAppMutation(c config, op Op, opts ...banappOption) *BanAppMutation {
	m := &BanAppMutation{
		config:        c,
		op:            op,
		typ:           TypeBanApp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBanAppID sets the ID field of the mutation.
func withBanAppID(id uuid.UUID) banappOption {
	return func(m *BanAppMutation) {
		var (
			err   error
			once  sync.Once
			value *BanApp
		)
		m.oldValue = func(ctx context.Context) (*BanApp, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BanApp.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBanApp sets the old BanApp of the mutation.
func withBanApp(node *BanApp) banappOption {
	return func(m *BanAppMutation) {
		m.oldValue = func(context.Context) (*BanApp, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BanAppMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BanAppMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BanApp entities.
func (m *BanAppMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BanAppMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BanAppMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BanApp.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BanAppMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BanAppMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BanApp entity.
// If the BanApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanAppMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *BanAppMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *BanAppMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BanAppMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BanAppMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BanAppMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BanApp entity.
// If the BanApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanAppMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *BanAppMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *BanAppMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BanAppMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BanAppMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BanAppMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the BanApp entity.
// If the BanApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanAppMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *BanAppMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *BanAppMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BanAppMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *BanAppMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *BanAppMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the BanApp entity.
// If the BanApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanAppMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *BanAppMutation) ResetAppID() {
	m.app_id = nil
}

// SetMessage sets the "message" field.
func (m *BanAppMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *BanAppMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the BanApp entity.
// If the BanApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanAppMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *BanAppMutation) ResetMessage() {
	m.message = nil
}

// Where appends a list predicates to the BanAppMutation builder.
func (m *BanAppMutation) Where(ps ...predicate.BanApp) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BanAppMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (BanApp).
func (m *BanAppMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BanAppMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, banapp.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, banapp.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, banapp.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, banapp.FieldAppID)
	}
	if m.message != nil {
		fields = append(fields, banapp.FieldMessage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BanAppMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case banapp.FieldCreatedAt:
		return m.CreatedAt()
	case banapp.FieldUpdatedAt:
		return m.UpdatedAt()
	case banapp.FieldDeletedAt:
		return m.DeletedAt()
	case banapp.FieldAppID:
		return m.AppID()
	case banapp.FieldMessage:
		return m.Message()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BanAppMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case banapp.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case banapp.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case banapp.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case banapp.FieldAppID:
		return m.OldAppID(ctx)
	case banapp.FieldMessage:
		return m.OldMessage(ctx)
	}
	return nil, fmt.Errorf("unknown BanApp field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BanAppMutation) SetField(name string, value ent.Value) error {
	switch name {
	case banapp.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case banapp.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case banapp.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case banapp.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case banapp.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	}
	return fmt.Errorf("unknown BanApp field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BanAppMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, banapp.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, banapp.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, banapp.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BanAppMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case banapp.FieldCreatedAt:
		return m.AddedCreatedAt()
	case banapp.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case banapp.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BanAppMutation) AddField(name string, value ent.Value) error {
	switch name {
	case banapp.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case banapp.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case banapp.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BanApp numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BanAppMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BanAppMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BanAppMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BanApp nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BanAppMutation) ResetField(name string) error {
	switch name {
	case banapp.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case banapp.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case banapp.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case banapp.FieldAppID:
		m.ResetAppID()
		return nil
	case banapp.FieldMessage:
		m.ResetMessage()
		return nil
	}
	return fmt.Errorf("unknown BanApp field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BanAppMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BanAppMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BanAppMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BanAppMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BanAppMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BanAppMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BanAppMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BanApp unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BanAppMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BanApp edge %s", name)
}

// BanAppUserMutation represents an operation that mutates the BanAppUser nodes in the graph.
type BanAppUserMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	app_id        *uuid.UUID
	user_id       *uuid.UUID
	message       *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*BanAppUser, error)
	predicates    []predicate.BanAppUser
}

var _ ent.Mutation = (*BanAppUserMutation)(nil)

// banappuserOption allows management of the mutation configuration using functional options.
type banappuserOption func(*BanAppUserMutation)

// newBanAppUserMutation creates new mutation for the BanAppUser entity.
func newBanAppUserMutation(c config, op Op, opts ...banappuserOption) *BanAppUserMutation {
	m := &BanAppUserMutation{
		config:        c,
		op:            op,
		typ:           TypeBanAppUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBanAppUserID sets the ID field of the mutation.
func withBanAppUserID(id uuid.UUID) banappuserOption {
	return func(m *BanAppUserMutation) {
		var (
			err   error
			once  sync.Once
			value *BanAppUser
		)
		m.oldValue = func(ctx context.Context) (*BanAppUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BanAppUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBanAppUser sets the old BanAppUser of the mutation.
func withBanAppUser(node *BanAppUser) banappuserOption {
	return func(m *BanAppUserMutation) {
		m.oldValue = func(context.Context) (*BanAppUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BanAppUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BanAppUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BanAppUser entities.
func (m *BanAppUserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BanAppUserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BanAppUserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BanAppUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BanAppUserMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BanAppUserMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BanAppUser entity.
// If the BanAppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanAppUserMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *BanAppUserMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *BanAppUserMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BanAppUserMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BanAppUserMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BanAppUserMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BanAppUser entity.
// If the BanAppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanAppUserMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *BanAppUserMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *BanAppUserMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BanAppUserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BanAppUserMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BanAppUserMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the BanAppUser entity.
// If the BanAppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanAppUserMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *BanAppUserMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *BanAppUserMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BanAppUserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *BanAppUserMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *BanAppUserMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the BanAppUser entity.
// If the BanAppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanAppUserMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *BanAppUserMutation) ResetAppID() {
	m.app_id = nil
}

// SetUserID sets the "user_id" field.
func (m *BanAppUserMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *BanAppUserMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the BanAppUser entity.
// If the BanAppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanAppUserMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *BanAppUserMutation) ResetUserID() {
	m.user_id = nil
}

// SetMessage sets the "message" field.
func (m *BanAppUserMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *BanAppUserMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the BanAppUser entity.
// If the BanAppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanAppUserMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *BanAppUserMutation) ResetMessage() {
	m.message = nil
}

// Where appends a list predicates to the BanAppUserMutation builder.
func (m *BanAppUserMutation) Where(ps ...predicate.BanAppUser) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BanAppUserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (BanAppUser).
func (m *BanAppUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BanAppUserMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, banappuser.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, banappuser.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, banappuser.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, banappuser.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, banappuser.FieldUserID)
	}
	if m.message != nil {
		fields = append(fields, banappuser.FieldMessage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BanAppUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case banappuser.FieldCreatedAt:
		return m.CreatedAt()
	case banappuser.FieldUpdatedAt:
		return m.UpdatedAt()
	case banappuser.FieldDeletedAt:
		return m.DeletedAt()
	case banappuser.FieldAppID:
		return m.AppID()
	case banappuser.FieldUserID:
		return m.UserID()
	case banappuser.FieldMessage:
		return m.Message()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BanAppUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case banappuser.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case banappuser.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case banappuser.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case banappuser.FieldAppID:
		return m.OldAppID(ctx)
	case banappuser.FieldUserID:
		return m.OldUserID(ctx)
	case banappuser.FieldMessage:
		return m.OldMessage(ctx)
	}
	return nil, fmt.Errorf("unknown BanAppUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BanAppUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case banappuser.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case banappuser.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case banappuser.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case banappuser.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case banappuser.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case banappuser.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	}
	return fmt.Errorf("unknown BanAppUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BanAppUserMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, banappuser.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, banappuser.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, banappuser.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BanAppUserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case banappuser.FieldCreatedAt:
		return m.AddedCreatedAt()
	case banappuser.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case banappuser.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BanAppUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case banappuser.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case banappuser.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case banappuser.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BanAppUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BanAppUserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BanAppUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BanAppUserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BanAppUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BanAppUserMutation) ResetField(name string) error {
	switch name {
	case banappuser.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case banappuser.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case banappuser.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case banappuser.FieldAppID:
		m.ResetAppID()
		return nil
	case banappuser.FieldUserID:
		m.ResetUserID()
		return nil
	case banappuser.FieldMessage:
		m.ResetMessage()
		return nil
	}
	return fmt.Errorf("unknown BanAppUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BanAppUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BanAppUserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BanAppUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BanAppUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BanAppUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BanAppUserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BanAppUserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BanAppUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BanAppUserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BanAppUser edge %s", name)
}

// KycMutation represents an operation that mutates the Kyc nodes in the graph.
type KycMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	app_id        *uuid.UUID
	user_id       *uuid.UUID
	document_type *string
	id_number     *string
	front_img     *string
	back_img      *string
	selfie_img    *string
	entity_type   *string
	review_id     *uuid.UUID
	review_state  *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Kyc, error)
	predicates    []predicate.Kyc
}

var _ ent.Mutation = (*KycMutation)(nil)

// kycOption allows management of the mutation configuration using functional options.
type kycOption func(*KycMutation)

// newKycMutation creates new mutation for the Kyc entity.
func newKycMutation(c config, op Op, opts ...kycOption) *KycMutation {
	m := &KycMutation{
		config:        c,
		op:            op,
		typ:           TypeKyc,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKycID sets the ID field of the mutation.
func withKycID(id uuid.UUID) kycOption {
	return func(m *KycMutation) {
		var (
			err   error
			once  sync.Once
			value *Kyc
		)
		m.oldValue = func(ctx context.Context) (*Kyc, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Kyc.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKyc sets the old Kyc of the mutation.
func withKyc(node *Kyc) kycOption {
	return func(m *KycMutation) {
		m.oldValue = func(context.Context) (*Kyc, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KycMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KycMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Kyc entities.
func (m *KycMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *KycMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *KycMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Kyc.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *KycMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *KycMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Kyc entity.
// If the Kyc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KycMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *KycMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *KycMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *KycMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *KycMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *KycMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Kyc entity.
// If the Kyc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KycMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *KycMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *KycMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *KycMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *KycMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *KycMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Kyc entity.
// If the Kyc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KycMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *KycMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *KycMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *KycMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *KycMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *KycMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Kyc entity.
// If the Kyc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KycMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *KycMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[kyc.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *KycMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[kyc.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *KycMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, kyc.FieldAppID)
}

// SetUserID sets the "user_id" field.
func (m *KycMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *KycMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Kyc entity.
// If the Kyc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KycMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *KycMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[kyc.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *KycMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[kyc.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *KycMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, kyc.FieldUserID)
}

// SetDocumentType sets the "document_type" field.
func (m *KycMutation) SetDocumentType(s string) {
	m.document_type = &s
}

// DocumentType returns the value of the "document_type" field in the mutation.
func (m *KycMutation) DocumentType() (r string, exists bool) {
	v := m.document_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentType returns the old "document_type" field's value of the Kyc entity.
// If the Kyc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KycMutation) OldDocumentType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentType: %w", err)
	}
	return oldValue.DocumentType, nil
}

// ClearDocumentType clears the value of the "document_type" field.
func (m *KycMutation) ClearDocumentType() {
	m.document_type = nil
	m.clearedFields[kyc.FieldDocumentType] = struct{}{}
}

// DocumentTypeCleared returns if the "document_type" field was cleared in this mutation.
func (m *KycMutation) DocumentTypeCleared() bool {
	_, ok := m.clearedFields[kyc.FieldDocumentType]
	return ok
}

// ResetDocumentType resets all changes to the "document_type" field.
func (m *KycMutation) ResetDocumentType() {
	m.document_type = nil
	delete(m.clearedFields, kyc.FieldDocumentType)
}

// SetIDNumber sets the "id_number" field.
func (m *KycMutation) SetIDNumber(s string) {
	m.id_number = &s
}

// IDNumber returns the value of the "id_number" field in the mutation.
func (m *KycMutation) IDNumber() (r string, exists bool) {
	v := m.id_number
	if v == nil {
		return
	}
	return *v, true
}

// OldIDNumber returns the old "id_number" field's value of the Kyc entity.
// If the Kyc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KycMutation) OldIDNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIDNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIDNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIDNumber: %w", err)
	}
	return oldValue.IDNumber, nil
}

// ClearIDNumber clears the value of the "id_number" field.
func (m *KycMutation) ClearIDNumber() {
	m.id_number = nil
	m.clearedFields[kyc.FieldIDNumber] = struct{}{}
}

// IDNumberCleared returns if the "id_number" field was cleared in this mutation.
func (m *KycMutation) IDNumberCleared() bool {
	_, ok := m.clearedFields[kyc.FieldIDNumber]
	return ok
}

// ResetIDNumber resets all changes to the "id_number" field.
func (m *KycMutation) ResetIDNumber() {
	m.id_number = nil
	delete(m.clearedFields, kyc.FieldIDNumber)
}

// SetFrontImg sets the "front_img" field.
func (m *KycMutation) SetFrontImg(s string) {
	m.front_img = &s
}

// FrontImg returns the value of the "front_img" field in the mutation.
func (m *KycMutation) FrontImg() (r string, exists bool) {
	v := m.front_img
	if v == nil {
		return
	}
	return *v, true
}

// OldFrontImg returns the old "front_img" field's value of the Kyc entity.
// If the Kyc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KycMutation) OldFrontImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrontImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrontImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrontImg: %w", err)
	}
	return oldValue.FrontImg, nil
}

// ClearFrontImg clears the value of the "front_img" field.
func (m *KycMutation) ClearFrontImg() {
	m.front_img = nil
	m.clearedFields[kyc.FieldFrontImg] = struct{}{}
}

// FrontImgCleared returns if the "front_img" field was cleared in this mutation.
func (m *KycMutation) FrontImgCleared() bool {
	_, ok := m.clearedFields[kyc.FieldFrontImg]
	return ok
}

// ResetFrontImg resets all changes to the "front_img" field.
func (m *KycMutation) ResetFrontImg() {
	m.front_img = nil
	delete(m.clearedFields, kyc.FieldFrontImg)
}

// SetBackImg sets the "back_img" field.
func (m *KycMutation) SetBackImg(s string) {
	m.back_img = &s
}

// BackImg returns the value of the "back_img" field in the mutation.
func (m *KycMutation) BackImg() (r string, exists bool) {
	v := m.back_img
	if v == nil {
		return
	}
	return *v, true
}

// OldBackImg returns the old "back_img" field's value of the Kyc entity.
// If the Kyc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KycMutation) OldBackImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBackImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBackImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBackImg: %w", err)
	}
	return oldValue.BackImg, nil
}

// ClearBackImg clears the value of the "back_img" field.
func (m *KycMutation) ClearBackImg() {
	m.back_img = nil
	m.clearedFields[kyc.FieldBackImg] = struct{}{}
}

// BackImgCleared returns if the "back_img" field was cleared in this mutation.
func (m *KycMutation) BackImgCleared() bool {
	_, ok := m.clearedFields[kyc.FieldBackImg]
	return ok
}

// ResetBackImg resets all changes to the "back_img" field.
func (m *KycMutation) ResetBackImg() {
	m.back_img = nil
	delete(m.clearedFields, kyc.FieldBackImg)
}

// SetSelfieImg sets the "selfie_img" field.
func (m *KycMutation) SetSelfieImg(s string) {
	m.selfie_img = &s
}

// SelfieImg returns the value of the "selfie_img" field in the mutation.
func (m *KycMutation) SelfieImg() (r string, exists bool) {
	v := m.selfie_img
	if v == nil {
		return
	}
	return *v, true
}

// OldSelfieImg returns the old "selfie_img" field's value of the Kyc entity.
// If the Kyc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KycMutation) OldSelfieImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSelfieImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSelfieImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSelfieImg: %w", err)
	}
	return oldValue.SelfieImg, nil
}

// ClearSelfieImg clears the value of the "selfie_img" field.
func (m *KycMutation) ClearSelfieImg() {
	m.selfie_img = nil
	m.clearedFields[kyc.FieldSelfieImg] = struct{}{}
}

// SelfieImgCleared returns if the "selfie_img" field was cleared in this mutation.
func (m *KycMutation) SelfieImgCleared() bool {
	_, ok := m.clearedFields[kyc.FieldSelfieImg]
	return ok
}

// ResetSelfieImg resets all changes to the "selfie_img" field.
func (m *KycMutation) ResetSelfieImg() {
	m.selfie_img = nil
	delete(m.clearedFields, kyc.FieldSelfieImg)
}

// SetEntityType sets the "entity_type" field.
func (m *KycMutation) SetEntityType(s string) {
	m.entity_type = &s
}

// EntityType returns the value of the "entity_type" field in the mutation.
func (m *KycMutation) EntityType() (r string, exists bool) {
	v := m.entity_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEntityType returns the old "entity_type" field's value of the Kyc entity.
// If the Kyc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KycMutation) OldEntityType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntityType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntityType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntityType: %w", err)
	}
	return oldValue.EntityType, nil
}

// ClearEntityType clears the value of the "entity_type" field.
func (m *KycMutation) ClearEntityType() {
	m.entity_type = nil
	m.clearedFields[kyc.FieldEntityType] = struct{}{}
}

// EntityTypeCleared returns if the "entity_type" field was cleared in this mutation.
func (m *KycMutation) EntityTypeCleared() bool {
	_, ok := m.clearedFields[kyc.FieldEntityType]
	return ok
}

// ResetEntityType resets all changes to the "entity_type" field.
func (m *KycMutation) ResetEntityType() {
	m.entity_type = nil
	delete(m.clearedFields, kyc.FieldEntityType)
}

// SetReviewID sets the "review_id" field.
func (m *KycMutation) SetReviewID(u uuid.UUID) {
	m.review_id = &u
}

// ReviewID returns the value of the "review_id" field in the mutation.
func (m *KycMutation) ReviewID() (r uuid.UUID, exists bool) {
	v := m.review_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewID returns the old "review_id" field's value of the Kyc entity.
// If the Kyc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KycMutation) OldReviewID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewID: %w", err)
	}
	return oldValue.ReviewID, nil
}

// ClearReviewID clears the value of the "review_id" field.
func (m *KycMutation) ClearReviewID() {
	m.review_id = nil
	m.clearedFields[kyc.FieldReviewID] = struct{}{}
}

// ReviewIDCleared returns if the "review_id" field was cleared in this mutation.
func (m *KycMutation) ReviewIDCleared() bool {
	_, ok := m.clearedFields[kyc.FieldReviewID]
	return ok
}

// ResetReviewID resets all changes to the "review_id" field.
func (m *KycMutation) ResetReviewID() {
	m.review_id = nil
	delete(m.clearedFields, kyc.FieldReviewID)
}

// SetReviewState sets the "review_state" field.
func (m *KycMutation) SetReviewState(s string) {
	m.review_state = &s
}

// ReviewState returns the value of the "review_state" field in the mutation.
func (m *KycMutation) ReviewState() (r string, exists bool) {
	v := m.review_state
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewState returns the old "review_state" field's value of the Kyc entity.
// If the Kyc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KycMutation) OldReviewState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewState: %w", err)
	}
	return oldValue.ReviewState, nil
}

// ClearReviewState clears the value of the "review_state" field.
func (m *KycMutation) ClearReviewState() {
	m.review_state = nil
	m.clearedFields[kyc.FieldReviewState] = struct{}{}
}

// ReviewStateCleared returns if the "review_state" field was cleared in this mutation.
func (m *KycMutation) ReviewStateCleared() bool {
	_, ok := m.clearedFields[kyc.FieldReviewState]
	return ok
}

// ResetReviewState resets all changes to the "review_state" field.
func (m *KycMutation) ResetReviewState() {
	m.review_state = nil
	delete(m.clearedFields, kyc.FieldReviewState)
}

// Where appends a list predicates to the KycMutation builder.
func (m *KycMutation) Where(ps ...predicate.Kyc) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *KycMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Kyc).
func (m *KycMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *KycMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, kyc.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, kyc.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, kyc.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, kyc.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, kyc.FieldUserID)
	}
	if m.document_type != nil {
		fields = append(fields, kyc.FieldDocumentType)
	}
	if m.id_number != nil {
		fields = append(fields, kyc.FieldIDNumber)
	}
	if m.front_img != nil {
		fields = append(fields, kyc.FieldFrontImg)
	}
	if m.back_img != nil {
		fields = append(fields, kyc.FieldBackImg)
	}
	if m.selfie_img != nil {
		fields = append(fields, kyc.FieldSelfieImg)
	}
	if m.entity_type != nil {
		fields = append(fields, kyc.FieldEntityType)
	}
	if m.review_id != nil {
		fields = append(fields, kyc.FieldReviewID)
	}
	if m.review_state != nil {
		fields = append(fields, kyc.FieldReviewState)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *KycMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case kyc.FieldCreatedAt:
		return m.CreatedAt()
	case kyc.FieldUpdatedAt:
		return m.UpdatedAt()
	case kyc.FieldDeletedAt:
		return m.DeletedAt()
	case kyc.FieldAppID:
		return m.AppID()
	case kyc.FieldUserID:
		return m.UserID()
	case kyc.FieldDocumentType:
		return m.DocumentType()
	case kyc.FieldIDNumber:
		return m.IDNumber()
	case kyc.FieldFrontImg:
		return m.FrontImg()
	case kyc.FieldBackImg:
		return m.BackImg()
	case kyc.FieldSelfieImg:
		return m.SelfieImg()
	case kyc.FieldEntityType:
		return m.EntityType()
	case kyc.FieldReviewID:
		return m.ReviewID()
	case kyc.FieldReviewState:
		return m.ReviewState()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *KycMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case kyc.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case kyc.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case kyc.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case kyc.FieldAppID:
		return m.OldAppID(ctx)
	case kyc.FieldUserID:
		return m.OldUserID(ctx)
	case kyc.FieldDocumentType:
		return m.OldDocumentType(ctx)
	case kyc.FieldIDNumber:
		return m.OldIDNumber(ctx)
	case kyc.FieldFrontImg:
		return m.OldFrontImg(ctx)
	case kyc.FieldBackImg:
		return m.OldBackImg(ctx)
	case kyc.FieldSelfieImg:
		return m.OldSelfieImg(ctx)
	case kyc.FieldEntityType:
		return m.OldEntityType(ctx)
	case kyc.FieldReviewID:
		return m.OldReviewID(ctx)
	case kyc.FieldReviewState:
		return m.OldReviewState(ctx)
	}
	return nil, fmt.Errorf("unknown Kyc field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KycMutation) SetField(name string, value ent.Value) error {
	switch name {
	case kyc.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case kyc.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case kyc.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case kyc.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case kyc.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case kyc.FieldDocumentType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentType(v)
		return nil
	case kyc.FieldIDNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIDNumber(v)
		return nil
	case kyc.FieldFrontImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrontImg(v)
		return nil
	case kyc.FieldBackImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBackImg(v)
		return nil
	case kyc.FieldSelfieImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSelfieImg(v)
		return nil
	case kyc.FieldEntityType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntityType(v)
		return nil
	case kyc.FieldReviewID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewID(v)
		return nil
	case kyc.FieldReviewState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewState(v)
		return nil
	}
	return fmt.Errorf("unknown Kyc field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *KycMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, kyc.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, kyc.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, kyc.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *KycMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case kyc.FieldCreatedAt:
		return m.AddedCreatedAt()
	case kyc.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case kyc.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KycMutation) AddField(name string, value ent.Value) error {
	switch name {
	case kyc.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case kyc.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case kyc.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Kyc numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *KycMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(kyc.FieldAppID) {
		fields = append(fields, kyc.FieldAppID)
	}
	if m.FieldCleared(kyc.FieldUserID) {
		fields = append(fields, kyc.FieldUserID)
	}
	if m.FieldCleared(kyc.FieldDocumentType) {
		fields = append(fields, kyc.FieldDocumentType)
	}
	if m.FieldCleared(kyc.FieldIDNumber) {
		fields = append(fields, kyc.FieldIDNumber)
	}
	if m.FieldCleared(kyc.FieldFrontImg) {
		fields = append(fields, kyc.FieldFrontImg)
	}
	if m.FieldCleared(kyc.FieldBackImg) {
		fields = append(fields, kyc.FieldBackImg)
	}
	if m.FieldCleared(kyc.FieldSelfieImg) {
		fields = append(fields, kyc.FieldSelfieImg)
	}
	if m.FieldCleared(kyc.FieldEntityType) {
		fields = append(fields, kyc.FieldEntityType)
	}
	if m.FieldCleared(kyc.FieldReviewID) {
		fields = append(fields, kyc.FieldReviewID)
	}
	if m.FieldCleared(kyc.FieldReviewState) {
		fields = append(fields, kyc.FieldReviewState)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *KycMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *KycMutation) ClearField(name string) error {
	switch name {
	case kyc.FieldAppID:
		m.ClearAppID()
		return nil
	case kyc.FieldUserID:
		m.ClearUserID()
		return nil
	case kyc.FieldDocumentType:
		m.ClearDocumentType()
		return nil
	case kyc.FieldIDNumber:
		m.ClearIDNumber()
		return nil
	case kyc.FieldFrontImg:
		m.ClearFrontImg()
		return nil
	case kyc.FieldBackImg:
		m.ClearBackImg()
		return nil
	case kyc.FieldSelfieImg:
		m.ClearSelfieImg()
		return nil
	case kyc.FieldEntityType:
		m.ClearEntityType()
		return nil
	case kyc.FieldReviewID:
		m.ClearReviewID()
		return nil
	case kyc.FieldReviewState:
		m.ClearReviewState()
		return nil
	}
	return fmt.Errorf("unknown Kyc nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *KycMutation) ResetField(name string) error {
	switch name {
	case kyc.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case kyc.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case kyc.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case kyc.FieldAppID:
		m.ResetAppID()
		return nil
	case kyc.FieldUserID:
		m.ResetUserID()
		return nil
	case kyc.FieldDocumentType:
		m.ResetDocumentType()
		return nil
	case kyc.FieldIDNumber:
		m.ResetIDNumber()
		return nil
	case kyc.FieldFrontImg:
		m.ResetFrontImg()
		return nil
	case kyc.FieldBackImg:
		m.ResetBackImg()
		return nil
	case kyc.FieldSelfieImg:
		m.ResetSelfieImg()
		return nil
	case kyc.FieldEntityType:
		m.ResetEntityType()
		return nil
	case kyc.FieldReviewID:
		m.ResetReviewID()
		return nil
	case kyc.FieldReviewState:
		m.ResetReviewState()
		return nil
	}
	return fmt.Errorf("unknown Kyc field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *KycMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *KycMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *KycMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *KycMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *KycMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *KycMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *KycMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Kyc unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *KycMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Kyc edge %s", name)
}

// LoginHistoryMutation represents an operation that mutates the LoginHistory nodes in the graph.
type LoginHistoryMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	app_id        *uuid.UUID
	user_id       *uuid.UUID
	client_ip     *string
	user_agent    *string
	location      *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*LoginHistory, error)
	predicates    []predicate.LoginHistory
}

var _ ent.Mutation = (*LoginHistoryMutation)(nil)

// loginhistoryOption allows management of the mutation configuration using functional options.
type loginhistoryOption func(*LoginHistoryMutation)

// newLoginHistoryMutation creates new mutation for the LoginHistory entity.
func newLoginHistoryMutation(c config, op Op, opts ...loginhistoryOption) *LoginHistoryMutation {
	m := &LoginHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeLoginHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLoginHistoryID sets the ID field of the mutation.
func withLoginHistoryID(id uuid.UUID) loginhistoryOption {
	return func(m *LoginHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *LoginHistory
		)
		m.oldValue = func(ctx context.Context) (*LoginHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LoginHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLoginHistory sets the old LoginHistory of the mutation.
func withLoginHistory(node *LoginHistory) loginhistoryOption {
	return func(m *LoginHistoryMutation) {
		m.oldValue = func(context.Context) (*LoginHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LoginHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LoginHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of LoginHistory entities.
func (m *LoginHistoryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LoginHistoryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LoginHistoryMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LoginHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *LoginHistoryMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LoginHistoryMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the LoginHistory entity.
// If the LoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginHistoryMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *LoginHistoryMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *LoginHistoryMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LoginHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LoginHistoryMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LoginHistoryMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the LoginHistory entity.
// If the LoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginHistoryMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *LoginHistoryMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *LoginHistoryMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LoginHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *LoginHistoryMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *LoginHistoryMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the LoginHistory entity.
// If the LoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginHistoryMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *LoginHistoryMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *LoginHistoryMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *LoginHistoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *LoginHistoryMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *LoginHistoryMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the LoginHistory entity.
// If the LoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginHistoryMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *LoginHistoryMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[loginhistory.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *LoginHistoryMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[loginhistory.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *LoginHistoryMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, loginhistory.FieldAppID)
}

// SetUserID sets the "user_id" field.
func (m *LoginHistoryMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *LoginHistoryMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the LoginHistory entity.
// If the LoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginHistoryMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *LoginHistoryMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[loginhistory.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *LoginHistoryMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[loginhistory.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *LoginHistoryMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, loginhistory.FieldUserID)
}

// SetClientIP sets the "client_ip" field.
func (m *LoginHistoryMutation) SetClientIP(s string) {
	m.client_ip = &s
}

// ClientIP returns the value of the "client_ip" field in the mutation.
func (m *LoginHistoryMutation) ClientIP() (r string, exists bool) {
	v := m.client_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldClientIP returns the old "client_ip" field's value of the LoginHistory entity.
// If the LoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginHistoryMutation) OldClientIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientIP: %w", err)
	}
	return oldValue.ClientIP, nil
}

// ClearClientIP clears the value of the "client_ip" field.
func (m *LoginHistoryMutation) ClearClientIP() {
	m.client_ip = nil
	m.clearedFields[loginhistory.FieldClientIP] = struct{}{}
}

// ClientIPCleared returns if the "client_ip" field was cleared in this mutation.
func (m *LoginHistoryMutation) ClientIPCleared() bool {
	_, ok := m.clearedFields[loginhistory.FieldClientIP]
	return ok
}

// ResetClientIP resets all changes to the "client_ip" field.
func (m *LoginHistoryMutation) ResetClientIP() {
	m.client_ip = nil
	delete(m.clearedFields, loginhistory.FieldClientIP)
}

// SetUserAgent sets the "user_agent" field.
func (m *LoginHistoryMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *LoginHistoryMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the LoginHistory entity.
// If the LoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginHistoryMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *LoginHistoryMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[loginhistory.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *LoginHistoryMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[loginhistory.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *LoginHistoryMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, loginhistory.FieldUserAgent)
}

// SetLocation sets the "location" field.
func (m *LoginHistoryMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *LoginHistoryMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the LoginHistory entity.
// If the LoginHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoginHistoryMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *LoginHistoryMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[loginhistory.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *LoginHistoryMutation) LocationCleared() bool {
	_, ok := m.clearedFields[loginhistory.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *LoginHistoryMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, loginhistory.FieldLocation)
}

// Where appends a list predicates to the LoginHistoryMutation builder.
func (m *LoginHistoryMutation) Where(ps ...predicate.LoginHistory) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *LoginHistoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (LoginHistory).
func (m *LoginHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LoginHistoryMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, loginhistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, loginhistory.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, loginhistory.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, loginhistory.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, loginhistory.FieldUserID)
	}
	if m.client_ip != nil {
		fields = append(fields, loginhistory.FieldClientIP)
	}
	if m.user_agent != nil {
		fields = append(fields, loginhistory.FieldUserAgent)
	}
	if m.location != nil {
		fields = append(fields, loginhistory.FieldLocation)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LoginHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case loginhistory.FieldCreatedAt:
		return m.CreatedAt()
	case loginhistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case loginhistory.FieldDeletedAt:
		return m.DeletedAt()
	case loginhistory.FieldAppID:
		return m.AppID()
	case loginhistory.FieldUserID:
		return m.UserID()
	case loginhistory.FieldClientIP:
		return m.ClientIP()
	case loginhistory.FieldUserAgent:
		return m.UserAgent()
	case loginhistory.FieldLocation:
		return m.Location()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LoginHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case loginhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case loginhistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case loginhistory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case loginhistory.FieldAppID:
		return m.OldAppID(ctx)
	case loginhistory.FieldUserID:
		return m.OldUserID(ctx)
	case loginhistory.FieldClientIP:
		return m.OldClientIP(ctx)
	case loginhistory.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case loginhistory.FieldLocation:
		return m.OldLocation(ctx)
	}
	return nil, fmt.Errorf("unknown LoginHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LoginHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case loginhistory.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case loginhistory.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case loginhistory.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case loginhistory.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case loginhistory.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case loginhistory.FieldClientIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientIP(v)
		return nil
	case loginhistory.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case loginhistory.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	}
	return fmt.Errorf("unknown LoginHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LoginHistoryMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, loginhistory.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, loginhistory.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, loginhistory.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LoginHistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case loginhistory.FieldCreatedAt:
		return m.AddedCreatedAt()
	case loginhistory.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case loginhistory.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LoginHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case loginhistory.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case loginhistory.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case loginhistory.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown LoginHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LoginHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(loginhistory.FieldAppID) {
		fields = append(fields, loginhistory.FieldAppID)
	}
	if m.FieldCleared(loginhistory.FieldUserID) {
		fields = append(fields, loginhistory.FieldUserID)
	}
	if m.FieldCleared(loginhistory.FieldClientIP) {
		fields = append(fields, loginhistory.FieldClientIP)
	}
	if m.FieldCleared(loginhistory.FieldUserAgent) {
		fields = append(fields, loginhistory.FieldUserAgent)
	}
	if m.FieldCleared(loginhistory.FieldLocation) {
		fields = append(fields, loginhistory.FieldLocation)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LoginHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LoginHistoryMutation) ClearField(name string) error {
	switch name {
	case loginhistory.FieldAppID:
		m.ClearAppID()
		return nil
	case loginhistory.FieldUserID:
		m.ClearUserID()
		return nil
	case loginhistory.FieldClientIP:
		m.ClearClientIP()
		return nil
	case loginhistory.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case loginhistory.FieldLocation:
		m.ClearLocation()
		return nil
	}
	return fmt.Errorf("unknown LoginHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LoginHistoryMutation) ResetField(name string) error {
	switch name {
	case loginhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case loginhistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case loginhistory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case loginhistory.FieldAppID:
		m.ResetAppID()
		return nil
	case loginhistory.FieldUserID:
		m.ResetUserID()
		return nil
	case loginhistory.FieldClientIP:
		m.ResetClientIP()
		return nil
	case loginhistory.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case loginhistory.FieldLocation:
		m.ResetLocation()
		return nil
	}
	return fmt.Errorf("unknown LoginHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LoginHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LoginHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LoginHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LoginHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LoginHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LoginHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LoginHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown LoginHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LoginHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown LoginHistory edge %s", name)
}
