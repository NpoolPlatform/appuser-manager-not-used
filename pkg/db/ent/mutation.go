// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"

	"github.com/NpoolPlatform/appuser-manager/pkg/db/ent/app"
	"github.com/NpoolPlatform/appuser-manager/pkg/db/ent/appcontrol"
	"github.com/NpoolPlatform/appuser-manager/pkg/db/ent/approle"
	"github.com/NpoolPlatform/appuser-manager/pkg/db/ent/approleuser"
	"github.com/NpoolPlatform/appuser-manager/pkg/db/ent/appuser"
	"github.com/NpoolPlatform/appuser-manager/pkg/db/ent/appusercontrol"
	"github.com/NpoolPlatform/appuser-manager/pkg/db/ent/appuserextra"
	"github.com/NpoolPlatform/appuser-manager/pkg/db/ent/appusersecret"
	"github.com/NpoolPlatform/appuser-manager/pkg/db/ent/appuserthirdparty"
	"github.com/NpoolPlatform/appuser-manager/pkg/db/ent/banapp"
	"github.com/NpoolPlatform/appuser-manager/pkg/db/ent/banappuser"
	"github.com/NpoolPlatform/appuser-manager/pkg/db/ent/predicate"
	"github.com/google/uuid"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeApp               = "App"
	TypeAppControl        = "AppControl"
	TypeAppRole           = "AppRole"
	TypeAppRoleUser       = "AppRoleUser"
	TypeAppUser           = "AppUser"
	TypeAppUserControl    = "AppUserControl"
	TypeAppUserExtra      = "AppUserExtra"
	TypeAppUserSecret     = "AppUserSecret"
	TypeAppUserThirdParty = "AppUserThirdParty"
	TypeBanApp            = "BanApp"
	TypeBanAppUser        = "BanAppUser"
)

// AppMutation represents an operation that mutates the App nodes in the graph.
type AppMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	created_by    *uuid.UUID
	name          *string
	logo          *string
	description   *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*App, error)
	predicates    []predicate.App
}

var _ ent.Mutation = (*AppMutation)(nil)

// appOption allows management of the mutation configuration using functional options.
type appOption func(*AppMutation)

// newAppMutation creates new mutation for the App entity.
func newAppMutation(c config, op Op, opts ...appOption) *AppMutation {
	m := &AppMutation{
		config:        c,
		op:            op,
		typ:           TypeApp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppID sets the ID field of the mutation.
func withAppID(id uuid.UUID) appOption {
	return func(m *AppMutation) {
		var (
			err   error
			once  sync.Once
			value *App
		)
		m.oldValue = func(ctx context.Context) (*App, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().App.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApp sets the old App of the mutation.
func withApp(node *App) appOption {
	return func(m *AppMutation) {
		m.oldValue = func(context.Context) (*App, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of App entities.
func (m *AppMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().App.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *AppMutation) SetCreatedBy(u uuid.UUID) {
	m.created_by = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AppMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AppMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetName sets the "name" field.
func (m *AppMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AppMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AppMutation) ResetName() {
	m.name = nil
}

// SetLogo sets the "logo" field.
func (m *AppMutation) SetLogo(s string) {
	m.logo = &s
}

// Logo returns the value of the "logo" field in the mutation.
func (m *AppMutation) Logo() (r string, exists bool) {
	v := m.logo
	if v == nil {
		return
	}
	return *v, true
}

// OldLogo returns the old "logo" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldLogo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogo: %w", err)
	}
	return oldValue.Logo, nil
}

// ResetLogo resets all changes to the "logo" field.
func (m *AppMutation) ResetLogo() {
	m.logo = nil
}

// SetDescription sets the "description" field.
func (m *AppMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AppMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *AppMutation) ResetDescription() {
	m.description = nil
}

// Where appends a list predicates to the AppMutation builder.
func (m *AppMutation) Where(ps ...predicate.App) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AppMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (App).
func (m *AppMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, app.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, app.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, app.FieldDeletedAt)
	}
	if m.created_by != nil {
		fields = append(fields, app.FieldCreatedBy)
	}
	if m.name != nil {
		fields = append(fields, app.FieldName)
	}
	if m.logo != nil {
		fields = append(fields, app.FieldLogo)
	}
	if m.description != nil {
		fields = append(fields, app.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case app.FieldCreatedAt:
		return m.CreatedAt()
	case app.FieldUpdatedAt:
		return m.UpdatedAt()
	case app.FieldDeletedAt:
		return m.DeletedAt()
	case app.FieldCreatedBy:
		return m.CreatedBy()
	case app.FieldName:
		return m.Name()
	case app.FieldLogo:
		return m.Logo()
	case app.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case app.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case app.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case app.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case app.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case app.FieldName:
		return m.OldName(ctx)
	case app.FieldLogo:
		return m.OldLogo(ctx)
	case app.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown App field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMutation) SetField(name string, value ent.Value) error {
	switch name {
	case app.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case app.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case app.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case app.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case app.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case app.FieldLogo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogo(v)
		return nil
	case app.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, app.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, app.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, app.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case app.FieldCreatedAt:
		return m.AddedCreatedAt()
	case app.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case app.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMutation) AddField(name string, value ent.Value) error {
	switch name {
	case app.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case app.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case app.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown App numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppMutation) ClearField(name string) error {
	return fmt.Errorf("unknown App nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppMutation) ResetField(name string) error {
	switch name {
	case app.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case app.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case app.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case app.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case app.FieldName:
		m.ResetName()
		return nil
	case app.FieldLogo:
		m.ResetLogo()
		return nil
	case app.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown App unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown App edge %s", name)
}

// AppControlMutation represents an operation that mutates the AppControl nodes in the graph.
type AppControlMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	created_at            *uint32
	addcreated_at         *int32
	updated_at            *uint32
	addupdated_at         *int32
	deleted_at            *uint32
	adddeleted_at         *int32
	app_id                *uuid.UUID
	signup_methods        *[]string
	extern_signin_methods *[]string
	recaptcha_method      *string
	kyc_enable            *bool
	signin_verify_enable  *bool
	invitation_code_must  *bool
	clearedFields         map[string]struct{}
	done                  bool
	oldValue              func(context.Context) (*AppControl, error)
	predicates            []predicate.AppControl
}

var _ ent.Mutation = (*AppControlMutation)(nil)

// appcontrolOption allows management of the mutation configuration using functional options.
type appcontrolOption func(*AppControlMutation)

// newAppControlMutation creates new mutation for the AppControl entity.
func newAppControlMutation(c config, op Op, opts ...appcontrolOption) *AppControlMutation {
	m := &AppControlMutation{
		config:        c,
		op:            op,
		typ:           TypeAppControl,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppControlID sets the ID field of the mutation.
func withAppControlID(id uuid.UUID) appcontrolOption {
	return func(m *AppControlMutation) {
		var (
			err   error
			once  sync.Once
			value *AppControl
		)
		m.oldValue = func(ctx context.Context) (*AppControl, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppControl.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppControl sets the old AppControl of the mutation.
func withAppControl(node *AppControl) appcontrolOption {
	return func(m *AppControlMutation) {
		m.oldValue = func(context.Context) (*AppControl, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppControlMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppControlMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppControl entities.
func (m *AppControlMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppControlMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppControlMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppControl.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppControlMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppControlMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppControl entity.
// If the AppControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppControlMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppControlMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppControlMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppControlMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppControlMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppControlMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppControl entity.
// If the AppControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppControlMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppControlMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppControlMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppControlMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppControlMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppControlMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppControl entity.
// If the AppControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppControlMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppControlMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppControlMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppControlMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *AppControlMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppControlMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppControl entity.
// If the AppControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppControlMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppControlMutation) ResetAppID() {
	m.app_id = nil
}

// SetSignupMethods sets the "signup_methods" field.
func (m *AppControlMutation) SetSignupMethods(s []string) {
	m.signup_methods = &s
}

// SignupMethods returns the value of the "signup_methods" field in the mutation.
func (m *AppControlMutation) SignupMethods() (r []string, exists bool) {
	v := m.signup_methods
	if v == nil {
		return
	}
	return *v, true
}

// OldSignupMethods returns the old "signup_methods" field's value of the AppControl entity.
// If the AppControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppControlMutation) OldSignupMethods(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignupMethods is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignupMethods requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignupMethods: %w", err)
	}
	return oldValue.SignupMethods, nil
}

// ResetSignupMethods resets all changes to the "signup_methods" field.
func (m *AppControlMutation) ResetSignupMethods() {
	m.signup_methods = nil
}

// SetExternSigninMethods sets the "extern_signin_methods" field.
func (m *AppControlMutation) SetExternSigninMethods(s []string) {
	m.extern_signin_methods = &s
}

// ExternSigninMethods returns the value of the "extern_signin_methods" field in the mutation.
func (m *AppControlMutation) ExternSigninMethods() (r []string, exists bool) {
	v := m.extern_signin_methods
	if v == nil {
		return
	}
	return *v, true
}

// OldExternSigninMethods returns the old "extern_signin_methods" field's value of the AppControl entity.
// If the AppControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppControlMutation) OldExternSigninMethods(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternSigninMethods is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternSigninMethods requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternSigninMethods: %w", err)
	}
	return oldValue.ExternSigninMethods, nil
}

// ResetExternSigninMethods resets all changes to the "extern_signin_methods" field.
func (m *AppControlMutation) ResetExternSigninMethods() {
	m.extern_signin_methods = nil
}

// SetRecaptchaMethod sets the "recaptcha_method" field.
func (m *AppControlMutation) SetRecaptchaMethod(s string) {
	m.recaptcha_method = &s
}

// RecaptchaMethod returns the value of the "recaptcha_method" field in the mutation.
func (m *AppControlMutation) RecaptchaMethod() (r string, exists bool) {
	v := m.recaptcha_method
	if v == nil {
		return
	}
	return *v, true
}

// OldRecaptchaMethod returns the old "recaptcha_method" field's value of the AppControl entity.
// If the AppControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppControlMutation) OldRecaptchaMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecaptchaMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecaptchaMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecaptchaMethod: %w", err)
	}
	return oldValue.RecaptchaMethod, nil
}

// ResetRecaptchaMethod resets all changes to the "recaptcha_method" field.
func (m *AppControlMutation) ResetRecaptchaMethod() {
	m.recaptcha_method = nil
}

// SetKycEnable sets the "kyc_enable" field.
func (m *AppControlMutation) SetKycEnable(b bool) {
	m.kyc_enable = &b
}

// KycEnable returns the value of the "kyc_enable" field in the mutation.
func (m *AppControlMutation) KycEnable() (r bool, exists bool) {
	v := m.kyc_enable
	if v == nil {
		return
	}
	return *v, true
}

// OldKycEnable returns the old "kyc_enable" field's value of the AppControl entity.
// If the AppControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppControlMutation) OldKycEnable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKycEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKycEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKycEnable: %w", err)
	}
	return oldValue.KycEnable, nil
}

// ResetKycEnable resets all changes to the "kyc_enable" field.
func (m *AppControlMutation) ResetKycEnable() {
	m.kyc_enable = nil
}

// SetSigninVerifyEnable sets the "signin_verify_enable" field.
func (m *AppControlMutation) SetSigninVerifyEnable(b bool) {
	m.signin_verify_enable = &b
}

// SigninVerifyEnable returns the value of the "signin_verify_enable" field in the mutation.
func (m *AppControlMutation) SigninVerifyEnable() (r bool, exists bool) {
	v := m.signin_verify_enable
	if v == nil {
		return
	}
	return *v, true
}

// OldSigninVerifyEnable returns the old "signin_verify_enable" field's value of the AppControl entity.
// If the AppControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppControlMutation) OldSigninVerifyEnable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSigninVerifyEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSigninVerifyEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSigninVerifyEnable: %w", err)
	}
	return oldValue.SigninVerifyEnable, nil
}

// ResetSigninVerifyEnable resets all changes to the "signin_verify_enable" field.
func (m *AppControlMutation) ResetSigninVerifyEnable() {
	m.signin_verify_enable = nil
}

// SetInvitationCodeMust sets the "invitation_code_must" field.
func (m *AppControlMutation) SetInvitationCodeMust(b bool) {
	m.invitation_code_must = &b
}

// InvitationCodeMust returns the value of the "invitation_code_must" field in the mutation.
func (m *AppControlMutation) InvitationCodeMust() (r bool, exists bool) {
	v := m.invitation_code_must
	if v == nil {
		return
	}
	return *v, true
}

// OldInvitationCodeMust returns the old "invitation_code_must" field's value of the AppControl entity.
// If the AppControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppControlMutation) OldInvitationCodeMust(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvitationCodeMust is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvitationCodeMust requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvitationCodeMust: %w", err)
	}
	return oldValue.InvitationCodeMust, nil
}

// ResetInvitationCodeMust resets all changes to the "invitation_code_must" field.
func (m *AppControlMutation) ResetInvitationCodeMust() {
	m.invitation_code_must = nil
}

// Where appends a list predicates to the AppControlMutation builder.
func (m *AppControlMutation) Where(ps ...predicate.AppControl) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AppControlMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AppControl).
func (m *AppControlMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppControlMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, appcontrol.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appcontrol.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appcontrol.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, appcontrol.FieldAppID)
	}
	if m.signup_methods != nil {
		fields = append(fields, appcontrol.FieldSignupMethods)
	}
	if m.extern_signin_methods != nil {
		fields = append(fields, appcontrol.FieldExternSigninMethods)
	}
	if m.recaptcha_method != nil {
		fields = append(fields, appcontrol.FieldRecaptchaMethod)
	}
	if m.kyc_enable != nil {
		fields = append(fields, appcontrol.FieldKycEnable)
	}
	if m.signin_verify_enable != nil {
		fields = append(fields, appcontrol.FieldSigninVerifyEnable)
	}
	if m.invitation_code_must != nil {
		fields = append(fields, appcontrol.FieldInvitationCodeMust)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppControlMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appcontrol.FieldCreatedAt:
		return m.CreatedAt()
	case appcontrol.FieldUpdatedAt:
		return m.UpdatedAt()
	case appcontrol.FieldDeletedAt:
		return m.DeletedAt()
	case appcontrol.FieldAppID:
		return m.AppID()
	case appcontrol.FieldSignupMethods:
		return m.SignupMethods()
	case appcontrol.FieldExternSigninMethods:
		return m.ExternSigninMethods()
	case appcontrol.FieldRecaptchaMethod:
		return m.RecaptchaMethod()
	case appcontrol.FieldKycEnable:
		return m.KycEnable()
	case appcontrol.FieldSigninVerifyEnable:
		return m.SigninVerifyEnable()
	case appcontrol.FieldInvitationCodeMust:
		return m.InvitationCodeMust()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppControlMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appcontrol.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appcontrol.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appcontrol.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appcontrol.FieldAppID:
		return m.OldAppID(ctx)
	case appcontrol.FieldSignupMethods:
		return m.OldSignupMethods(ctx)
	case appcontrol.FieldExternSigninMethods:
		return m.OldExternSigninMethods(ctx)
	case appcontrol.FieldRecaptchaMethod:
		return m.OldRecaptchaMethod(ctx)
	case appcontrol.FieldKycEnable:
		return m.OldKycEnable(ctx)
	case appcontrol.FieldSigninVerifyEnable:
		return m.OldSigninVerifyEnable(ctx)
	case appcontrol.FieldInvitationCodeMust:
		return m.OldInvitationCodeMust(ctx)
	}
	return nil, fmt.Errorf("unknown AppControl field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppControlMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appcontrol.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appcontrol.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appcontrol.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appcontrol.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appcontrol.FieldSignupMethods:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignupMethods(v)
		return nil
	case appcontrol.FieldExternSigninMethods:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternSigninMethods(v)
		return nil
	case appcontrol.FieldRecaptchaMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecaptchaMethod(v)
		return nil
	case appcontrol.FieldKycEnable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKycEnable(v)
		return nil
	case appcontrol.FieldSigninVerifyEnable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSigninVerifyEnable(v)
		return nil
	case appcontrol.FieldInvitationCodeMust:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvitationCodeMust(v)
		return nil
	}
	return fmt.Errorf("unknown AppControl field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppControlMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, appcontrol.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, appcontrol.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, appcontrol.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppControlMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appcontrol.FieldCreatedAt:
		return m.AddedCreatedAt()
	case appcontrol.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case appcontrol.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppControlMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appcontrol.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case appcontrol.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case appcontrol.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppControl numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppControlMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppControlMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppControlMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AppControl nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppControlMutation) ResetField(name string) error {
	switch name {
	case appcontrol.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appcontrol.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appcontrol.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appcontrol.FieldAppID:
		m.ResetAppID()
		return nil
	case appcontrol.FieldSignupMethods:
		m.ResetSignupMethods()
		return nil
	case appcontrol.FieldExternSigninMethods:
		m.ResetExternSigninMethods()
		return nil
	case appcontrol.FieldRecaptchaMethod:
		m.ResetRecaptchaMethod()
		return nil
	case appcontrol.FieldKycEnable:
		m.ResetKycEnable()
		return nil
	case appcontrol.FieldSigninVerifyEnable:
		m.ResetSigninVerifyEnable()
		return nil
	case appcontrol.FieldInvitationCodeMust:
		m.ResetInvitationCodeMust()
		return nil
	}
	return fmt.Errorf("unknown AppControl field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppControlMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppControlMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppControlMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppControlMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppControlMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppControlMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppControlMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppControl unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppControlMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppControl edge %s", name)
}

// AppRoleMutation represents an operation that mutates the AppRole nodes in the graph.
type AppRoleMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	created_by    *uuid.UUID
	role          *string
	description   *string
	app_id        *uuid.UUID
	_default      *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AppRole, error)
	predicates    []predicate.AppRole
}

var _ ent.Mutation = (*AppRoleMutation)(nil)

// approleOption allows management of the mutation configuration using functional options.
type approleOption func(*AppRoleMutation)

// newAppRoleMutation creates new mutation for the AppRole entity.
func newAppRoleMutation(c config, op Op, opts ...approleOption) *AppRoleMutation {
	m := &AppRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeAppRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppRoleID sets the ID field of the mutation.
func withAppRoleID(id uuid.UUID) approleOption {
	return func(m *AppRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *AppRole
		)
		m.oldValue = func(ctx context.Context) (*AppRole, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppRole sets the old AppRole of the mutation.
func withAppRole(node *AppRole) approleOption {
	return func(m *AppRoleMutation) {
		m.oldValue = func(context.Context) (*AppRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppRole entities.
func (m *AppRoleMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppRoleMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppRoleMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppRole.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppRoleMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppRoleMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppRoleMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppRoleMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppRoleMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppRoleMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppRoleMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppRoleMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppRoleMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppRoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppRoleMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppRoleMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppRoleMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppRoleMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppRoleMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *AppRoleMutation) SetCreatedBy(u uuid.UUID) {
	m.created_by = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AppRoleMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AppRoleMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetRole sets the "role" field.
func (m *AppRoleMutation) SetRole(s string) {
	m.role = &s
}

// Role returns the value of the "role" field in the mutation.
func (m *AppRoleMutation) Role() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *AppRoleMutation) ResetRole() {
	m.role = nil
}

// SetDescription sets the "description" field.
func (m *AppRoleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AppRoleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *AppRoleMutation) ResetDescription() {
	m.description = nil
}

// SetAppID sets the "app_id" field.
func (m *AppRoleMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppRoleMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppRoleMutation) ResetAppID() {
	m.app_id = nil
}

// SetDefault sets the "default" field.
func (m *AppRoleMutation) SetDefault(b bool) {
	m._default = &b
}

// Default returns the value of the "default" field in the mutation.
func (m *AppRoleMutation) Default() (r bool, exists bool) {
	v := m._default
	if v == nil {
		return
	}
	return *v, true
}

// OldDefault returns the old "default" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefault: %w", err)
	}
	return oldValue.Default, nil
}

// ResetDefault resets all changes to the "default" field.
func (m *AppRoleMutation) ResetDefault() {
	m._default = nil
}

// Where appends a list predicates to the AppRoleMutation builder.
func (m *AppRoleMutation) Where(ps ...predicate.AppRole) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AppRoleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AppRole).
func (m *AppRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppRoleMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, approle.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, approle.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, approle.FieldDeletedAt)
	}
	if m.created_by != nil {
		fields = append(fields, approle.FieldCreatedBy)
	}
	if m.role != nil {
		fields = append(fields, approle.FieldRole)
	}
	if m.description != nil {
		fields = append(fields, approle.FieldDescription)
	}
	if m.app_id != nil {
		fields = append(fields, approle.FieldAppID)
	}
	if m._default != nil {
		fields = append(fields, approle.FieldDefault)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case approle.FieldCreatedAt:
		return m.CreatedAt()
	case approle.FieldUpdatedAt:
		return m.UpdatedAt()
	case approle.FieldDeletedAt:
		return m.DeletedAt()
	case approle.FieldCreatedBy:
		return m.CreatedBy()
	case approle.FieldRole:
		return m.Role()
	case approle.FieldDescription:
		return m.Description()
	case approle.FieldAppID:
		return m.AppID()
	case approle.FieldDefault:
		return m.Default()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case approle.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case approle.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case approle.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case approle.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case approle.FieldRole:
		return m.OldRole(ctx)
	case approle.FieldDescription:
		return m.OldDescription(ctx)
	case approle.FieldAppID:
		return m.OldAppID(ctx)
	case approle.FieldDefault:
		return m.OldDefault(ctx)
	}
	return nil, fmt.Errorf("unknown AppRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case approle.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case approle.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case approle.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case approle.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case approle.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case approle.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case approle.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case approle.FieldDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefault(v)
		return nil
	}
	return fmt.Errorf("unknown AppRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppRoleMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, approle.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, approle.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, approle.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppRoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case approle.FieldCreatedAt:
		return m.AddedCreatedAt()
	case approle.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case approle.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case approle.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case approle.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case approle.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppRoleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppRoleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AppRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppRoleMutation) ResetField(name string) error {
	switch name {
	case approle.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case approle.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case approle.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case approle.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case approle.FieldRole:
		m.ResetRole()
		return nil
	case approle.FieldDescription:
		m.ResetDescription()
		return nil
	case approle.FieldAppID:
		m.ResetAppID()
		return nil
	case approle.FieldDefault:
		m.ResetDefault()
		return nil
	}
	return fmt.Errorf("unknown AppRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppRoleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppRoleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppRoleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppRoleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppRoleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppRole edge %s", name)
}

// AppRoleUserMutation represents an operation that mutates the AppRoleUser nodes in the graph.
type AppRoleUserMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	app_id        *uuid.UUID
	role_id       *uuid.UUID
	user_id       *uuid.UUID
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AppRoleUser, error)
	predicates    []predicate.AppRoleUser
}

var _ ent.Mutation = (*AppRoleUserMutation)(nil)

// approleuserOption allows management of the mutation configuration using functional options.
type approleuserOption func(*AppRoleUserMutation)

// newAppRoleUserMutation creates new mutation for the AppRoleUser entity.
func newAppRoleUserMutation(c config, op Op, opts ...approleuserOption) *AppRoleUserMutation {
	m := &AppRoleUserMutation{
		config:        c,
		op:            op,
		typ:           TypeAppRoleUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppRoleUserID sets the ID field of the mutation.
func withAppRoleUserID(id uuid.UUID) approleuserOption {
	return func(m *AppRoleUserMutation) {
		var (
			err   error
			once  sync.Once
			value *AppRoleUser
		)
		m.oldValue = func(ctx context.Context) (*AppRoleUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppRoleUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppRoleUser sets the old AppRoleUser of the mutation.
func withAppRoleUser(node *AppRoleUser) approleuserOption {
	return func(m *AppRoleUserMutation) {
		m.oldValue = func(context.Context) (*AppRoleUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppRoleUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppRoleUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppRoleUser entities.
func (m *AppRoleUserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppRoleUserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppRoleUserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppRoleUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppRoleUserMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppRoleUserMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppRoleUser entity.
// If the AppRoleUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleUserMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppRoleUserMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppRoleUserMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppRoleUserMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppRoleUserMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppRoleUserMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppRoleUser entity.
// If the AppRoleUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleUserMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppRoleUserMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppRoleUserMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppRoleUserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppRoleUserMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppRoleUserMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppRoleUser entity.
// If the AppRoleUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleUserMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppRoleUserMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppRoleUserMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppRoleUserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *AppRoleUserMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppRoleUserMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppRoleUser entity.
// If the AppRoleUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleUserMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppRoleUserMutation) ResetAppID() {
	m.app_id = nil
}

// SetRoleID sets the "role_id" field.
func (m *AppRoleUserMutation) SetRoleID(u uuid.UUID) {
	m.role_id = &u
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *AppRoleUserMutation) RoleID() (r uuid.UUID, exists bool) {
	v := m.role_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the AppRoleUser entity.
// If the AppRoleUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleUserMutation) OldRoleID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *AppRoleUserMutation) ResetRoleID() {
	m.role_id = nil
}

// SetUserID sets the "user_id" field.
func (m *AppRoleUserMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AppRoleUserMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AppRoleUser entity.
// If the AppRoleUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleUserMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AppRoleUserMutation) ResetUserID() {
	m.user_id = nil
}

// Where appends a list predicates to the AppRoleUserMutation builder.
func (m *AppRoleUserMutation) Where(ps ...predicate.AppRoleUser) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AppRoleUserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AppRoleUser).
func (m *AppRoleUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppRoleUserMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, approleuser.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, approleuser.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, approleuser.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, approleuser.FieldAppID)
	}
	if m.role_id != nil {
		fields = append(fields, approleuser.FieldRoleID)
	}
	if m.user_id != nil {
		fields = append(fields, approleuser.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppRoleUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case approleuser.FieldCreatedAt:
		return m.CreatedAt()
	case approleuser.FieldUpdatedAt:
		return m.UpdatedAt()
	case approleuser.FieldDeletedAt:
		return m.DeletedAt()
	case approleuser.FieldAppID:
		return m.AppID()
	case approleuser.FieldRoleID:
		return m.RoleID()
	case approleuser.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppRoleUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case approleuser.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case approleuser.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case approleuser.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case approleuser.FieldAppID:
		return m.OldAppID(ctx)
	case approleuser.FieldRoleID:
		return m.OldRoleID(ctx)
	case approleuser.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown AppRoleUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppRoleUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case approleuser.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case approleuser.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case approleuser.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case approleuser.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case approleuser.FieldRoleID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case approleuser.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown AppRoleUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppRoleUserMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, approleuser.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, approleuser.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, approleuser.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppRoleUserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case approleuser.FieldCreatedAt:
		return m.AddedCreatedAt()
	case approleuser.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case approleuser.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppRoleUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case approleuser.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case approleuser.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case approleuser.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppRoleUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppRoleUserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppRoleUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppRoleUserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AppRoleUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppRoleUserMutation) ResetField(name string) error {
	switch name {
	case approleuser.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case approleuser.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case approleuser.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case approleuser.FieldAppID:
		m.ResetAppID()
		return nil
	case approleuser.FieldRoleID:
		m.ResetRoleID()
		return nil
	case approleuser.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown AppRoleUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppRoleUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppRoleUserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppRoleUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppRoleUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppRoleUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppRoleUserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppRoleUserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppRoleUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppRoleUserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppRoleUser edge %s", name)
}

// AppUserMutation represents an operation that mutates the AppUser nodes in the graph.
type AppUserMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	created_at      *uint32
	addcreated_at   *int32
	updated_at      *uint32
	addupdated_at   *int32
	deleted_at      *uint32
	adddeleted_at   *int32
	app_id          *uuid.UUID
	email_address   *string
	phone_no        *string
	import_from_app *uuid.UUID
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*AppUser, error)
	predicates      []predicate.AppUser
}

var _ ent.Mutation = (*AppUserMutation)(nil)

// appuserOption allows management of the mutation configuration using functional options.
type appuserOption func(*AppUserMutation)

// newAppUserMutation creates new mutation for the AppUser entity.
func newAppUserMutation(c config, op Op, opts ...appuserOption) *AppUserMutation {
	m := &AppUserMutation{
		config:        c,
		op:            op,
		typ:           TypeAppUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppUserID sets the ID field of the mutation.
func withAppUserID(id uuid.UUID) appuserOption {
	return func(m *AppUserMutation) {
		var (
			err   error
			once  sync.Once
			value *AppUser
		)
		m.oldValue = func(ctx context.Context) (*AppUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppUser sets the old AppUser of the mutation.
func withAppUser(node *AppUser) appuserOption {
	return func(m *AppUserMutation) {
		m.oldValue = func(context.Context) (*AppUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppUser entities.
func (m *AppUserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppUserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppUserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppUserMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppUserMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppUserMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppUserMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppUserMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppUserMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppUserMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppUserMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppUserMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppUserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppUserMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppUserMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppUserMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppUserMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppUserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *AppUserMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppUserMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppUserMutation) ResetAppID() {
	m.app_id = nil
}

// SetEmailAddress sets the "email_address" field.
func (m *AppUserMutation) SetEmailAddress(s string) {
	m.email_address = &s
}

// EmailAddress returns the value of the "email_address" field in the mutation.
func (m *AppUserMutation) EmailAddress() (r string, exists bool) {
	v := m.email_address
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailAddress returns the old "email_address" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldEmailAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailAddress: %w", err)
	}
	return oldValue.EmailAddress, nil
}

// ResetEmailAddress resets all changes to the "email_address" field.
func (m *AppUserMutation) ResetEmailAddress() {
	m.email_address = nil
}

// SetPhoneNo sets the "phone_no" field.
func (m *AppUserMutation) SetPhoneNo(s string) {
	m.phone_no = &s
}

// PhoneNo returns the value of the "phone_no" field in the mutation.
func (m *AppUserMutation) PhoneNo() (r string, exists bool) {
	v := m.phone_no
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNo returns the old "phone_no" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldPhoneNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNo: %w", err)
	}
	return oldValue.PhoneNo, nil
}

// ResetPhoneNo resets all changes to the "phone_no" field.
func (m *AppUserMutation) ResetPhoneNo() {
	m.phone_no = nil
}

// SetImportFromApp sets the "import_from_app" field.
func (m *AppUserMutation) SetImportFromApp(u uuid.UUID) {
	m.import_from_app = &u
}

// ImportFromApp returns the value of the "import_from_app" field in the mutation.
func (m *AppUserMutation) ImportFromApp() (r uuid.UUID, exists bool) {
	v := m.import_from_app
	if v == nil {
		return
	}
	return *v, true
}

// OldImportFromApp returns the old "import_from_app" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldImportFromApp(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImportFromApp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImportFromApp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImportFromApp: %w", err)
	}
	return oldValue.ImportFromApp, nil
}

// ResetImportFromApp resets all changes to the "import_from_app" field.
func (m *AppUserMutation) ResetImportFromApp() {
	m.import_from_app = nil
}

// Where appends a list predicates to the AppUserMutation builder.
func (m *AppUserMutation) Where(ps ...predicate.AppUser) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AppUserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AppUser).
func (m *AppUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppUserMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, appuser.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appuser.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appuser.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, appuser.FieldAppID)
	}
	if m.email_address != nil {
		fields = append(fields, appuser.FieldEmailAddress)
	}
	if m.phone_no != nil {
		fields = append(fields, appuser.FieldPhoneNo)
	}
	if m.import_from_app != nil {
		fields = append(fields, appuser.FieldImportFromApp)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appuser.FieldCreatedAt:
		return m.CreatedAt()
	case appuser.FieldUpdatedAt:
		return m.UpdatedAt()
	case appuser.FieldDeletedAt:
		return m.DeletedAt()
	case appuser.FieldAppID:
		return m.AppID()
	case appuser.FieldEmailAddress:
		return m.EmailAddress()
	case appuser.FieldPhoneNo:
		return m.PhoneNo()
	case appuser.FieldImportFromApp:
		return m.ImportFromApp()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appuser.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appuser.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appuser.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appuser.FieldAppID:
		return m.OldAppID(ctx)
	case appuser.FieldEmailAddress:
		return m.OldEmailAddress(ctx)
	case appuser.FieldPhoneNo:
		return m.OldPhoneNo(ctx)
	case appuser.FieldImportFromApp:
		return m.OldImportFromApp(ctx)
	}
	return nil, fmt.Errorf("unknown AppUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appuser.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appuser.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appuser.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appuser.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appuser.FieldEmailAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailAddress(v)
		return nil
	case appuser.FieldPhoneNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNo(v)
		return nil
	case appuser.FieldImportFromApp:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImportFromApp(v)
		return nil
	}
	return fmt.Errorf("unknown AppUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppUserMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, appuser.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, appuser.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, appuser.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppUserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appuser.FieldCreatedAt:
		return m.AddedCreatedAt()
	case appuser.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case appuser.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appuser.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case appuser.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case appuser.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppUserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppUserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AppUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppUserMutation) ResetField(name string) error {
	switch name {
	case appuser.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appuser.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appuser.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appuser.FieldAppID:
		m.ResetAppID()
		return nil
	case appuser.FieldEmailAddress:
		m.ResetEmailAddress()
		return nil
	case appuser.FieldPhoneNo:
		m.ResetPhoneNo()
		return nil
	case appuser.FieldImportFromApp:
		m.ResetImportFromApp()
		return nil
	}
	return fmt.Errorf("unknown AppUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppUserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppUserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppUserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppUserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppUser edge %s", name)
}

// AppUserControlMutation represents an operation that mutates the AppUserControl nodes in the graph.
type AppUserControlMutation struct {
	config
	op                                     Op
	typ                                    string
	id                                     *uuid.UUID
	created_at                             *uint32
	addcreated_at                          *int32
	updated_at                             *uint32
	addupdated_at                          *int32
	deleted_at                             *uint32
	adddeleted_at                          *int32
	app_id                                 *uuid.UUID
	user_id                                *uuid.UUID
	signin_verify_by_google_authentication *bool
	google_authentication_verified         *bool
	clearedFields                          map[string]struct{}
	done                                   bool
	oldValue                               func(context.Context) (*AppUserControl, error)
	predicates                             []predicate.AppUserControl
}

var _ ent.Mutation = (*AppUserControlMutation)(nil)

// appusercontrolOption allows management of the mutation configuration using functional options.
type appusercontrolOption func(*AppUserControlMutation)

// newAppUserControlMutation creates new mutation for the AppUserControl entity.
func newAppUserControlMutation(c config, op Op, opts ...appusercontrolOption) *AppUserControlMutation {
	m := &AppUserControlMutation{
		config:        c,
		op:            op,
		typ:           TypeAppUserControl,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppUserControlID sets the ID field of the mutation.
func withAppUserControlID(id uuid.UUID) appusercontrolOption {
	return func(m *AppUserControlMutation) {
		var (
			err   error
			once  sync.Once
			value *AppUserControl
		)
		m.oldValue = func(ctx context.Context) (*AppUserControl, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppUserControl.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppUserControl sets the old AppUserControl of the mutation.
func withAppUserControl(node *AppUserControl) appusercontrolOption {
	return func(m *AppUserControlMutation) {
		m.oldValue = func(context.Context) (*AppUserControl, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppUserControlMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppUserControlMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppUserControl entities.
func (m *AppUserControlMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppUserControlMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppUserControlMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppUserControl.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppUserControlMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppUserControlMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppUserControl entity.
// If the AppUserControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserControlMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppUserControlMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppUserControlMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppUserControlMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppUserControlMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppUserControlMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppUserControl entity.
// If the AppUserControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserControlMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppUserControlMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppUserControlMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppUserControlMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppUserControlMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppUserControlMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppUserControl entity.
// If the AppUserControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserControlMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppUserControlMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppUserControlMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppUserControlMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *AppUserControlMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppUserControlMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppUserControl entity.
// If the AppUserControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserControlMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppUserControlMutation) ResetAppID() {
	m.app_id = nil
}

// SetUserID sets the "user_id" field.
func (m *AppUserControlMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AppUserControlMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AppUserControl entity.
// If the AppUserControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserControlMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AppUserControlMutation) ResetUserID() {
	m.user_id = nil
}

// SetSigninVerifyByGoogleAuthentication sets the "signin_verify_by_google_authentication" field.
func (m *AppUserControlMutation) SetSigninVerifyByGoogleAuthentication(b bool) {
	m.signin_verify_by_google_authentication = &b
}

// SigninVerifyByGoogleAuthentication returns the value of the "signin_verify_by_google_authentication" field in the mutation.
func (m *AppUserControlMutation) SigninVerifyByGoogleAuthentication() (r bool, exists bool) {
	v := m.signin_verify_by_google_authentication
	if v == nil {
		return
	}
	return *v, true
}

// OldSigninVerifyByGoogleAuthentication returns the old "signin_verify_by_google_authentication" field's value of the AppUserControl entity.
// If the AppUserControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserControlMutation) OldSigninVerifyByGoogleAuthentication(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSigninVerifyByGoogleAuthentication is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSigninVerifyByGoogleAuthentication requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSigninVerifyByGoogleAuthentication: %w", err)
	}
	return oldValue.SigninVerifyByGoogleAuthentication, nil
}

// ResetSigninVerifyByGoogleAuthentication resets all changes to the "signin_verify_by_google_authentication" field.
func (m *AppUserControlMutation) ResetSigninVerifyByGoogleAuthentication() {
	m.signin_verify_by_google_authentication = nil
}

// SetGoogleAuthenticationVerified sets the "google_authentication_verified" field.
func (m *AppUserControlMutation) SetGoogleAuthenticationVerified(b bool) {
	m.google_authentication_verified = &b
}

// GoogleAuthenticationVerified returns the value of the "google_authentication_verified" field in the mutation.
func (m *AppUserControlMutation) GoogleAuthenticationVerified() (r bool, exists bool) {
	v := m.google_authentication_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldGoogleAuthenticationVerified returns the old "google_authentication_verified" field's value of the AppUserControl entity.
// If the AppUserControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserControlMutation) OldGoogleAuthenticationVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoogleAuthenticationVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoogleAuthenticationVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoogleAuthenticationVerified: %w", err)
	}
	return oldValue.GoogleAuthenticationVerified, nil
}

// ResetGoogleAuthenticationVerified resets all changes to the "google_authentication_verified" field.
func (m *AppUserControlMutation) ResetGoogleAuthenticationVerified() {
	m.google_authentication_verified = nil
}

// Where appends a list predicates to the AppUserControlMutation builder.
func (m *AppUserControlMutation) Where(ps ...predicate.AppUserControl) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AppUserControlMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AppUserControl).
func (m *AppUserControlMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppUserControlMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, appusercontrol.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appusercontrol.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appusercontrol.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, appusercontrol.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, appusercontrol.FieldUserID)
	}
	if m.signin_verify_by_google_authentication != nil {
		fields = append(fields, appusercontrol.FieldSigninVerifyByGoogleAuthentication)
	}
	if m.google_authentication_verified != nil {
		fields = append(fields, appusercontrol.FieldGoogleAuthenticationVerified)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppUserControlMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appusercontrol.FieldCreatedAt:
		return m.CreatedAt()
	case appusercontrol.FieldUpdatedAt:
		return m.UpdatedAt()
	case appusercontrol.FieldDeletedAt:
		return m.DeletedAt()
	case appusercontrol.FieldAppID:
		return m.AppID()
	case appusercontrol.FieldUserID:
		return m.UserID()
	case appusercontrol.FieldSigninVerifyByGoogleAuthentication:
		return m.SigninVerifyByGoogleAuthentication()
	case appusercontrol.FieldGoogleAuthenticationVerified:
		return m.GoogleAuthenticationVerified()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppUserControlMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appusercontrol.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appusercontrol.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appusercontrol.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appusercontrol.FieldAppID:
		return m.OldAppID(ctx)
	case appusercontrol.FieldUserID:
		return m.OldUserID(ctx)
	case appusercontrol.FieldSigninVerifyByGoogleAuthentication:
		return m.OldSigninVerifyByGoogleAuthentication(ctx)
	case appusercontrol.FieldGoogleAuthenticationVerified:
		return m.OldGoogleAuthenticationVerified(ctx)
	}
	return nil, fmt.Errorf("unknown AppUserControl field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppUserControlMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appusercontrol.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appusercontrol.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appusercontrol.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appusercontrol.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appusercontrol.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case appusercontrol.FieldSigninVerifyByGoogleAuthentication:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSigninVerifyByGoogleAuthentication(v)
		return nil
	case appusercontrol.FieldGoogleAuthenticationVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoogleAuthenticationVerified(v)
		return nil
	}
	return fmt.Errorf("unknown AppUserControl field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppUserControlMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, appusercontrol.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, appusercontrol.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, appusercontrol.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppUserControlMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appusercontrol.FieldCreatedAt:
		return m.AddedCreatedAt()
	case appusercontrol.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case appusercontrol.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppUserControlMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appusercontrol.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case appusercontrol.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case appusercontrol.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppUserControl numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppUserControlMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppUserControlMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppUserControlMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AppUserControl nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppUserControlMutation) ResetField(name string) error {
	switch name {
	case appusercontrol.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appusercontrol.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appusercontrol.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appusercontrol.FieldAppID:
		m.ResetAppID()
		return nil
	case appusercontrol.FieldUserID:
		m.ResetUserID()
		return nil
	case appusercontrol.FieldSigninVerifyByGoogleAuthentication:
		m.ResetSigninVerifyByGoogleAuthentication()
		return nil
	case appusercontrol.FieldGoogleAuthenticationVerified:
		m.ResetGoogleAuthenticationVerified()
		return nil
	}
	return fmt.Errorf("unknown AppUserControl field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppUserControlMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppUserControlMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppUserControlMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppUserControlMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppUserControlMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppUserControlMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppUserControlMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppUserControl unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppUserControlMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppUserControl edge %s", name)
}

// AppUserExtraMutation represents an operation that mutates the AppUserExtra nodes in the graph.
type AppUserExtraMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	created_at     *uint32
	addcreated_at  *int32
	updated_at     *uint32
	addupdated_at  *int32
	deleted_at     *uint32
	adddeleted_at  *int32
	app_id         *uuid.UUID
	user_id        *uuid.UUID
	username       *string
	first_name     *string
	last_name      *string
	address_fields *[]string
	gender         *string
	postal_code    *string
	age            *uint32
	addage         *int32
	birthday       *uint32
	addbirthday    *int32
	avatar         *string
	organization   *string
	id_number      *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*AppUserExtra, error)
	predicates     []predicate.AppUserExtra
}

var _ ent.Mutation = (*AppUserExtraMutation)(nil)

// appuserextraOption allows management of the mutation configuration using functional options.
type appuserextraOption func(*AppUserExtraMutation)

// newAppUserExtraMutation creates new mutation for the AppUserExtra entity.
func newAppUserExtraMutation(c config, op Op, opts ...appuserextraOption) *AppUserExtraMutation {
	m := &AppUserExtraMutation{
		config:        c,
		op:            op,
		typ:           TypeAppUserExtra,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppUserExtraID sets the ID field of the mutation.
func withAppUserExtraID(id uuid.UUID) appuserextraOption {
	return func(m *AppUserExtraMutation) {
		var (
			err   error
			once  sync.Once
			value *AppUserExtra
		)
		m.oldValue = func(ctx context.Context) (*AppUserExtra, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppUserExtra.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppUserExtra sets the old AppUserExtra of the mutation.
func withAppUserExtra(node *AppUserExtra) appuserextraOption {
	return func(m *AppUserExtraMutation) {
		m.oldValue = func(context.Context) (*AppUserExtra, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppUserExtraMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppUserExtraMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppUserExtra entities.
func (m *AppUserExtraMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppUserExtraMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppUserExtraMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppUserExtra.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppUserExtraMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppUserExtraMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppUserExtraMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppUserExtraMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppUserExtraMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppUserExtraMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppUserExtraMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppUserExtraMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppUserExtraMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppUserExtraMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppUserExtraMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppUserExtraMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppUserExtraMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppUserExtraMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppUserExtraMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *AppUserExtraMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppUserExtraMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppUserExtraMutation) ResetAppID() {
	m.app_id = nil
}

// SetUserID sets the "user_id" field.
func (m *AppUserExtraMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AppUserExtraMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AppUserExtraMutation) ResetUserID() {
	m.user_id = nil
}

// SetUsername sets the "username" field.
func (m *AppUserExtraMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *AppUserExtraMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *AppUserExtraMutation) ResetUsername() {
	m.username = nil
}

// SetFirstName sets the "first_name" field.
func (m *AppUserExtraMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *AppUserExtraMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *AppUserExtraMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *AppUserExtraMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *AppUserExtraMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *AppUserExtraMutation) ResetLastName() {
	m.last_name = nil
}

// SetAddressFields sets the "address_fields" field.
func (m *AppUserExtraMutation) SetAddressFields(s []string) {
	m.address_fields = &s
}

// AddressFields returns the value of the "address_fields" field in the mutation.
func (m *AppUserExtraMutation) AddressFields() (r []string, exists bool) {
	v := m.address_fields
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressFields returns the old "address_fields" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldAddressFields(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddressFields is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddressFields requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressFields: %w", err)
	}
	return oldValue.AddressFields, nil
}

// ResetAddressFields resets all changes to the "address_fields" field.
func (m *AppUserExtraMutation) ResetAddressFields() {
	m.address_fields = nil
}

// SetGender sets the "gender" field.
func (m *AppUserExtraMutation) SetGender(s string) {
	m.gender = &s
}

// Gender returns the value of the "gender" field in the mutation.
func (m *AppUserExtraMutation) Gender() (r string, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldGender(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ResetGender resets all changes to the "gender" field.
func (m *AppUserExtraMutation) ResetGender() {
	m.gender = nil
}

// SetPostalCode sets the "postal_code" field.
func (m *AppUserExtraMutation) SetPostalCode(s string) {
	m.postal_code = &s
}

// PostalCode returns the value of the "postal_code" field in the mutation.
func (m *AppUserExtraMutation) PostalCode() (r string, exists bool) {
	v := m.postal_code
	if v == nil {
		return
	}
	return *v, true
}

// OldPostalCode returns the old "postal_code" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldPostalCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostalCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostalCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostalCode: %w", err)
	}
	return oldValue.PostalCode, nil
}

// ResetPostalCode resets all changes to the "postal_code" field.
func (m *AppUserExtraMutation) ResetPostalCode() {
	m.postal_code = nil
}

// SetAge sets the "age" field.
func (m *AppUserExtraMutation) SetAge(u uint32) {
	m.age = &u
	m.addage = nil
}

// Age returns the value of the "age" field in the mutation.
func (m *AppUserExtraMutation) Age() (r uint32, exists bool) {
	v := m.age
	if v == nil {
		return
	}
	return *v, true
}

// OldAge returns the old "age" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldAge(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAge: %w", err)
	}
	return oldValue.Age, nil
}

// AddAge adds u to the "age" field.
func (m *AppUserExtraMutation) AddAge(u int32) {
	if m.addage != nil {
		*m.addage += u
	} else {
		m.addage = &u
	}
}

// AddedAge returns the value that was added to the "age" field in this mutation.
func (m *AppUserExtraMutation) AddedAge() (r int32, exists bool) {
	v := m.addage
	if v == nil {
		return
	}
	return *v, true
}

// ResetAge resets all changes to the "age" field.
func (m *AppUserExtraMutation) ResetAge() {
	m.age = nil
	m.addage = nil
}

// SetBirthday sets the "birthday" field.
func (m *AppUserExtraMutation) SetBirthday(u uint32) {
	m.birthday = &u
	m.addbirthday = nil
}

// Birthday returns the value of the "birthday" field in the mutation.
func (m *AppUserExtraMutation) Birthday() (r uint32, exists bool) {
	v := m.birthday
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthday returns the old "birthday" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldBirthday(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirthday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirthday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthday: %w", err)
	}
	return oldValue.Birthday, nil
}

// AddBirthday adds u to the "birthday" field.
func (m *AppUserExtraMutation) AddBirthday(u int32) {
	if m.addbirthday != nil {
		*m.addbirthday += u
	} else {
		m.addbirthday = &u
	}
}

// AddedBirthday returns the value that was added to the "birthday" field in this mutation.
func (m *AppUserExtraMutation) AddedBirthday() (r int32, exists bool) {
	v := m.addbirthday
	if v == nil {
		return
	}
	return *v, true
}

// ResetBirthday resets all changes to the "birthday" field.
func (m *AppUserExtraMutation) ResetBirthday() {
	m.birthday = nil
	m.addbirthday = nil
}

// SetAvatar sets the "avatar" field.
func (m *AppUserExtraMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *AppUserExtraMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *AppUserExtraMutation) ResetAvatar() {
	m.avatar = nil
}

// SetOrganization sets the "organization" field.
func (m *AppUserExtraMutation) SetOrganization(s string) {
	m.organization = &s
}

// Organization returns the value of the "organization" field in the mutation.
func (m *AppUserExtraMutation) Organization() (r string, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganization returns the old "organization" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldOrganization(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganization is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganization requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganization: %w", err)
	}
	return oldValue.Organization, nil
}

// ResetOrganization resets all changes to the "organization" field.
func (m *AppUserExtraMutation) ResetOrganization() {
	m.organization = nil
}

// SetIDNumber sets the "id_number" field.
func (m *AppUserExtraMutation) SetIDNumber(s string) {
	m.id_number = &s
}

// IDNumber returns the value of the "id_number" field in the mutation.
func (m *AppUserExtraMutation) IDNumber() (r string, exists bool) {
	v := m.id_number
	if v == nil {
		return
	}
	return *v, true
}

// OldIDNumber returns the old "id_number" field's value of the AppUserExtra entity.
// If the AppUserExtra object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserExtraMutation) OldIDNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIDNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIDNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIDNumber: %w", err)
	}
	return oldValue.IDNumber, nil
}

// ResetIDNumber resets all changes to the "id_number" field.
func (m *AppUserExtraMutation) ResetIDNumber() {
	m.id_number = nil
}

// Where appends a list predicates to the AppUserExtraMutation builder.
func (m *AppUserExtraMutation) Where(ps ...predicate.AppUserExtra) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AppUserExtraMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AppUserExtra).
func (m *AppUserExtraMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppUserExtraMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, appuserextra.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appuserextra.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appuserextra.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, appuserextra.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, appuserextra.FieldUserID)
	}
	if m.username != nil {
		fields = append(fields, appuserextra.FieldUsername)
	}
	if m.first_name != nil {
		fields = append(fields, appuserextra.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, appuserextra.FieldLastName)
	}
	if m.address_fields != nil {
		fields = append(fields, appuserextra.FieldAddressFields)
	}
	if m.gender != nil {
		fields = append(fields, appuserextra.FieldGender)
	}
	if m.postal_code != nil {
		fields = append(fields, appuserextra.FieldPostalCode)
	}
	if m.age != nil {
		fields = append(fields, appuserextra.FieldAge)
	}
	if m.birthday != nil {
		fields = append(fields, appuserextra.FieldBirthday)
	}
	if m.avatar != nil {
		fields = append(fields, appuserextra.FieldAvatar)
	}
	if m.organization != nil {
		fields = append(fields, appuserextra.FieldOrganization)
	}
	if m.id_number != nil {
		fields = append(fields, appuserextra.FieldIDNumber)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppUserExtraMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appuserextra.FieldCreatedAt:
		return m.CreatedAt()
	case appuserextra.FieldUpdatedAt:
		return m.UpdatedAt()
	case appuserextra.FieldDeletedAt:
		return m.DeletedAt()
	case appuserextra.FieldAppID:
		return m.AppID()
	case appuserextra.FieldUserID:
		return m.UserID()
	case appuserextra.FieldUsername:
		return m.Username()
	case appuserextra.FieldFirstName:
		return m.FirstName()
	case appuserextra.FieldLastName:
		return m.LastName()
	case appuserextra.FieldAddressFields:
		return m.AddressFields()
	case appuserextra.FieldGender:
		return m.Gender()
	case appuserextra.FieldPostalCode:
		return m.PostalCode()
	case appuserextra.FieldAge:
		return m.Age()
	case appuserextra.FieldBirthday:
		return m.Birthday()
	case appuserextra.FieldAvatar:
		return m.Avatar()
	case appuserextra.FieldOrganization:
		return m.Organization()
	case appuserextra.FieldIDNumber:
		return m.IDNumber()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppUserExtraMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appuserextra.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appuserextra.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appuserextra.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appuserextra.FieldAppID:
		return m.OldAppID(ctx)
	case appuserextra.FieldUserID:
		return m.OldUserID(ctx)
	case appuserextra.FieldUsername:
		return m.OldUsername(ctx)
	case appuserextra.FieldFirstName:
		return m.OldFirstName(ctx)
	case appuserextra.FieldLastName:
		return m.OldLastName(ctx)
	case appuserextra.FieldAddressFields:
		return m.OldAddressFields(ctx)
	case appuserextra.FieldGender:
		return m.OldGender(ctx)
	case appuserextra.FieldPostalCode:
		return m.OldPostalCode(ctx)
	case appuserextra.FieldAge:
		return m.OldAge(ctx)
	case appuserextra.FieldBirthday:
		return m.OldBirthday(ctx)
	case appuserextra.FieldAvatar:
		return m.OldAvatar(ctx)
	case appuserextra.FieldOrganization:
		return m.OldOrganization(ctx)
	case appuserextra.FieldIDNumber:
		return m.OldIDNumber(ctx)
	}
	return nil, fmt.Errorf("unknown AppUserExtra field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppUserExtraMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appuserextra.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appuserextra.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appuserextra.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appuserextra.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appuserextra.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case appuserextra.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case appuserextra.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case appuserextra.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case appuserextra.FieldAddressFields:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressFields(v)
		return nil
	case appuserextra.FieldGender:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case appuserextra.FieldPostalCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostalCode(v)
		return nil
	case appuserextra.FieldAge:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAge(v)
		return nil
	case appuserextra.FieldBirthday:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthday(v)
		return nil
	case appuserextra.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case appuserextra.FieldOrganization:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganization(v)
		return nil
	case appuserextra.FieldIDNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIDNumber(v)
		return nil
	}
	return fmt.Errorf("unknown AppUserExtra field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppUserExtraMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, appuserextra.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, appuserextra.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, appuserextra.FieldDeletedAt)
	}
	if m.addage != nil {
		fields = append(fields, appuserextra.FieldAge)
	}
	if m.addbirthday != nil {
		fields = append(fields, appuserextra.FieldBirthday)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppUserExtraMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appuserextra.FieldCreatedAt:
		return m.AddedCreatedAt()
	case appuserextra.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case appuserextra.FieldDeletedAt:
		return m.AddedDeletedAt()
	case appuserextra.FieldAge:
		return m.AddedAge()
	case appuserextra.FieldBirthday:
		return m.AddedBirthday()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppUserExtraMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appuserextra.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case appuserextra.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case appuserextra.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case appuserextra.FieldAge:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAge(v)
		return nil
	case appuserextra.FieldBirthday:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBirthday(v)
		return nil
	}
	return fmt.Errorf("unknown AppUserExtra numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppUserExtraMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppUserExtraMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppUserExtraMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AppUserExtra nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppUserExtraMutation) ResetField(name string) error {
	switch name {
	case appuserextra.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appuserextra.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appuserextra.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appuserextra.FieldAppID:
		m.ResetAppID()
		return nil
	case appuserextra.FieldUserID:
		m.ResetUserID()
		return nil
	case appuserextra.FieldUsername:
		m.ResetUsername()
		return nil
	case appuserextra.FieldFirstName:
		m.ResetFirstName()
		return nil
	case appuserextra.FieldLastName:
		m.ResetLastName()
		return nil
	case appuserextra.FieldAddressFields:
		m.ResetAddressFields()
		return nil
	case appuserextra.FieldGender:
		m.ResetGender()
		return nil
	case appuserextra.FieldPostalCode:
		m.ResetPostalCode()
		return nil
	case appuserextra.FieldAge:
		m.ResetAge()
		return nil
	case appuserextra.FieldBirthday:
		m.ResetBirthday()
		return nil
	case appuserextra.FieldAvatar:
		m.ResetAvatar()
		return nil
	case appuserextra.FieldOrganization:
		m.ResetOrganization()
		return nil
	case appuserextra.FieldIDNumber:
		m.ResetIDNumber()
		return nil
	}
	return fmt.Errorf("unknown AppUserExtra field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppUserExtraMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppUserExtraMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppUserExtraMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppUserExtraMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppUserExtraMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppUserExtraMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppUserExtraMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppUserExtra unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppUserExtraMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppUserExtra edge %s", name)
}

// AppUserSecretMutation represents an operation that mutates the AppUserSecret nodes in the graph.
type AppUserSecretMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	app_id        *uuid.UUID
	user_id       *uuid.UUID
	password_hash *string
	salt          *string
	google_secret *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AppUserSecret, error)
	predicates    []predicate.AppUserSecret
}

var _ ent.Mutation = (*AppUserSecretMutation)(nil)

// appusersecretOption allows management of the mutation configuration using functional options.
type appusersecretOption func(*AppUserSecretMutation)

// newAppUserSecretMutation creates new mutation for the AppUserSecret entity.
func newAppUserSecretMutation(c config, op Op, opts ...appusersecretOption) *AppUserSecretMutation {
	m := &AppUserSecretMutation{
		config:        c,
		op:            op,
		typ:           TypeAppUserSecret,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppUserSecretID sets the ID field of the mutation.
func withAppUserSecretID(id uuid.UUID) appusersecretOption {
	return func(m *AppUserSecretMutation) {
		var (
			err   error
			once  sync.Once
			value *AppUserSecret
		)
		m.oldValue = func(ctx context.Context) (*AppUserSecret, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppUserSecret.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppUserSecret sets the old AppUserSecret of the mutation.
func withAppUserSecret(node *AppUserSecret) appusersecretOption {
	return func(m *AppUserSecretMutation) {
		m.oldValue = func(context.Context) (*AppUserSecret, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppUserSecretMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppUserSecretMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppUserSecret entities.
func (m *AppUserSecretMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppUserSecretMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppUserSecretMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppUserSecret.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppUserSecretMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppUserSecretMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppUserSecret entity.
// If the AppUserSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserSecretMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppUserSecretMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppUserSecretMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppUserSecretMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppUserSecretMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppUserSecretMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppUserSecret entity.
// If the AppUserSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserSecretMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppUserSecretMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppUserSecretMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppUserSecretMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppUserSecretMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppUserSecretMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppUserSecret entity.
// If the AppUserSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserSecretMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppUserSecretMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppUserSecretMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppUserSecretMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *AppUserSecretMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppUserSecretMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppUserSecret entity.
// If the AppUserSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserSecretMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppUserSecretMutation) ResetAppID() {
	m.app_id = nil
}

// SetUserID sets the "user_id" field.
func (m *AppUserSecretMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AppUserSecretMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AppUserSecret entity.
// If the AppUserSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserSecretMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AppUserSecretMutation) ResetUserID() {
	m.user_id = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *AppUserSecretMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *AppUserSecretMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the AppUserSecret entity.
// If the AppUserSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserSecretMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *AppUserSecretMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetSalt sets the "salt" field.
func (m *AppUserSecretMutation) SetSalt(s string) {
	m.salt = &s
}

// Salt returns the value of the "salt" field in the mutation.
func (m *AppUserSecretMutation) Salt() (r string, exists bool) {
	v := m.salt
	if v == nil {
		return
	}
	return *v, true
}

// OldSalt returns the old "salt" field's value of the AppUserSecret entity.
// If the AppUserSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserSecretMutation) OldSalt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalt: %w", err)
	}
	return oldValue.Salt, nil
}

// ResetSalt resets all changes to the "salt" field.
func (m *AppUserSecretMutation) ResetSalt() {
	m.salt = nil
}

// SetGoogleSecret sets the "google_secret" field.
func (m *AppUserSecretMutation) SetGoogleSecret(s string) {
	m.google_secret = &s
}

// GoogleSecret returns the value of the "google_secret" field in the mutation.
func (m *AppUserSecretMutation) GoogleSecret() (r string, exists bool) {
	v := m.google_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldGoogleSecret returns the old "google_secret" field's value of the AppUserSecret entity.
// If the AppUserSecret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserSecretMutation) OldGoogleSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoogleSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoogleSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoogleSecret: %w", err)
	}
	return oldValue.GoogleSecret, nil
}

// ResetGoogleSecret resets all changes to the "google_secret" field.
func (m *AppUserSecretMutation) ResetGoogleSecret() {
	m.google_secret = nil
}

// Where appends a list predicates to the AppUserSecretMutation builder.
func (m *AppUserSecretMutation) Where(ps ...predicate.AppUserSecret) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AppUserSecretMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AppUserSecret).
func (m *AppUserSecretMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppUserSecretMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, appusersecret.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appusersecret.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appusersecret.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, appusersecret.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, appusersecret.FieldUserID)
	}
	if m.password_hash != nil {
		fields = append(fields, appusersecret.FieldPasswordHash)
	}
	if m.salt != nil {
		fields = append(fields, appusersecret.FieldSalt)
	}
	if m.google_secret != nil {
		fields = append(fields, appusersecret.FieldGoogleSecret)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppUserSecretMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appusersecret.FieldCreatedAt:
		return m.CreatedAt()
	case appusersecret.FieldUpdatedAt:
		return m.UpdatedAt()
	case appusersecret.FieldDeletedAt:
		return m.DeletedAt()
	case appusersecret.FieldAppID:
		return m.AppID()
	case appusersecret.FieldUserID:
		return m.UserID()
	case appusersecret.FieldPasswordHash:
		return m.PasswordHash()
	case appusersecret.FieldSalt:
		return m.Salt()
	case appusersecret.FieldGoogleSecret:
		return m.GoogleSecret()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppUserSecretMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appusersecret.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appusersecret.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appusersecret.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appusersecret.FieldAppID:
		return m.OldAppID(ctx)
	case appusersecret.FieldUserID:
		return m.OldUserID(ctx)
	case appusersecret.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case appusersecret.FieldSalt:
		return m.OldSalt(ctx)
	case appusersecret.FieldGoogleSecret:
		return m.OldGoogleSecret(ctx)
	}
	return nil, fmt.Errorf("unknown AppUserSecret field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppUserSecretMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appusersecret.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appusersecret.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appusersecret.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appusersecret.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appusersecret.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case appusersecret.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case appusersecret.FieldSalt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalt(v)
		return nil
	case appusersecret.FieldGoogleSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoogleSecret(v)
		return nil
	}
	return fmt.Errorf("unknown AppUserSecret field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppUserSecretMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, appusersecret.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, appusersecret.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, appusersecret.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppUserSecretMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appusersecret.FieldCreatedAt:
		return m.AddedCreatedAt()
	case appusersecret.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case appusersecret.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppUserSecretMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appusersecret.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case appusersecret.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case appusersecret.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppUserSecret numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppUserSecretMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppUserSecretMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppUserSecretMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AppUserSecret nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppUserSecretMutation) ResetField(name string) error {
	switch name {
	case appusersecret.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appusersecret.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appusersecret.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appusersecret.FieldAppID:
		m.ResetAppID()
		return nil
	case appusersecret.FieldUserID:
		m.ResetUserID()
		return nil
	case appusersecret.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case appusersecret.FieldSalt:
		m.ResetSalt()
		return nil
	case appusersecret.FieldGoogleSecret:
		m.ResetGoogleSecret()
		return nil
	}
	return fmt.Errorf("unknown AppUserSecret field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppUserSecretMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppUserSecretMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppUserSecretMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppUserSecretMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppUserSecretMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppUserSecretMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppUserSecretMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppUserSecret unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppUserSecretMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppUserSecret edge %s", name)
}

// AppUserThirdPartyMutation represents an operation that mutates the AppUserThirdParty nodes in the graph.
type AppUserThirdPartyMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	created_at              *uint32
	addcreated_at           *int32
	updated_at              *uint32
	addupdated_at           *int32
	deleted_at              *uint32
	adddeleted_at           *int32
	app_id                  *uuid.UUID
	user_id                 *uuid.UUID
	third_party_user_id     *string
	third_party_id          *string
	third_party_username    *string
	third_party_user_avatar *string
	clearedFields           map[string]struct{}
	done                    bool
	oldValue                func(context.Context) (*AppUserThirdParty, error)
	predicates              []predicate.AppUserThirdParty
}

var _ ent.Mutation = (*AppUserThirdPartyMutation)(nil)

// appuserthirdpartyOption allows management of the mutation configuration using functional options.
type appuserthirdpartyOption func(*AppUserThirdPartyMutation)

// newAppUserThirdPartyMutation creates new mutation for the AppUserThirdParty entity.
func newAppUserThirdPartyMutation(c config, op Op, opts ...appuserthirdpartyOption) *AppUserThirdPartyMutation {
	m := &AppUserThirdPartyMutation{
		config:        c,
		op:            op,
		typ:           TypeAppUserThirdParty,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppUserThirdPartyID sets the ID field of the mutation.
func withAppUserThirdPartyID(id uuid.UUID) appuserthirdpartyOption {
	return func(m *AppUserThirdPartyMutation) {
		var (
			err   error
			once  sync.Once
			value *AppUserThirdParty
		)
		m.oldValue = func(ctx context.Context) (*AppUserThirdParty, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppUserThirdParty.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppUserThirdParty sets the old AppUserThirdParty of the mutation.
func withAppUserThirdParty(node *AppUserThirdParty) appuserthirdpartyOption {
	return func(m *AppUserThirdPartyMutation) {
		m.oldValue = func(context.Context) (*AppUserThirdParty, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppUserThirdPartyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppUserThirdPartyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppUserThirdParty entities.
func (m *AppUserThirdPartyMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppUserThirdPartyMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppUserThirdPartyMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppUserThirdParty.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppUserThirdPartyMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppUserThirdPartyMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppUserThirdParty entity.
// If the AppUserThirdParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserThirdPartyMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppUserThirdPartyMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppUserThirdPartyMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppUserThirdPartyMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppUserThirdPartyMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppUserThirdPartyMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppUserThirdParty entity.
// If the AppUserThirdParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserThirdPartyMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppUserThirdPartyMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppUserThirdPartyMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppUserThirdPartyMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppUserThirdPartyMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppUserThirdPartyMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppUserThirdParty entity.
// If the AppUserThirdParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserThirdPartyMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppUserThirdPartyMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppUserThirdPartyMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppUserThirdPartyMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *AppUserThirdPartyMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppUserThirdPartyMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppUserThirdParty entity.
// If the AppUserThirdParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserThirdPartyMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppUserThirdPartyMutation) ResetAppID() {
	m.app_id = nil
}

// SetUserID sets the "user_id" field.
func (m *AppUserThirdPartyMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AppUserThirdPartyMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AppUserThirdParty entity.
// If the AppUserThirdParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserThirdPartyMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AppUserThirdPartyMutation) ResetUserID() {
	m.user_id = nil
}

// SetThirdPartyUserID sets the "third_party_user_id" field.
func (m *AppUserThirdPartyMutation) SetThirdPartyUserID(s string) {
	m.third_party_user_id = &s
}

// ThirdPartyUserID returns the value of the "third_party_user_id" field in the mutation.
func (m *AppUserThirdPartyMutation) ThirdPartyUserID() (r string, exists bool) {
	v := m.third_party_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldThirdPartyUserID returns the old "third_party_user_id" field's value of the AppUserThirdParty entity.
// If the AppUserThirdParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserThirdPartyMutation) OldThirdPartyUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThirdPartyUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThirdPartyUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThirdPartyUserID: %w", err)
	}
	return oldValue.ThirdPartyUserID, nil
}

// ResetThirdPartyUserID resets all changes to the "third_party_user_id" field.
func (m *AppUserThirdPartyMutation) ResetThirdPartyUserID() {
	m.third_party_user_id = nil
}

// SetThirdPartyID sets the "third_party_id" field.
func (m *AppUserThirdPartyMutation) SetThirdPartyID(s string) {
	m.third_party_id = &s
}

// ThirdPartyID returns the value of the "third_party_id" field in the mutation.
func (m *AppUserThirdPartyMutation) ThirdPartyID() (r string, exists bool) {
	v := m.third_party_id
	if v == nil {
		return
	}
	return *v, true
}

// OldThirdPartyID returns the old "third_party_id" field's value of the AppUserThirdParty entity.
// If the AppUserThirdParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserThirdPartyMutation) OldThirdPartyID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThirdPartyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThirdPartyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThirdPartyID: %w", err)
	}
	return oldValue.ThirdPartyID, nil
}

// ResetThirdPartyID resets all changes to the "third_party_id" field.
func (m *AppUserThirdPartyMutation) ResetThirdPartyID() {
	m.third_party_id = nil
}

// SetThirdPartyUsername sets the "third_party_username" field.
func (m *AppUserThirdPartyMutation) SetThirdPartyUsername(s string) {
	m.third_party_username = &s
}

// ThirdPartyUsername returns the value of the "third_party_username" field in the mutation.
func (m *AppUserThirdPartyMutation) ThirdPartyUsername() (r string, exists bool) {
	v := m.third_party_username
	if v == nil {
		return
	}
	return *v, true
}

// OldThirdPartyUsername returns the old "third_party_username" field's value of the AppUserThirdParty entity.
// If the AppUserThirdParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserThirdPartyMutation) OldThirdPartyUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThirdPartyUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThirdPartyUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThirdPartyUsername: %w", err)
	}
	return oldValue.ThirdPartyUsername, nil
}

// ResetThirdPartyUsername resets all changes to the "third_party_username" field.
func (m *AppUserThirdPartyMutation) ResetThirdPartyUsername() {
	m.third_party_username = nil
}

// SetThirdPartyUserAvatar sets the "third_party_user_avatar" field.
func (m *AppUserThirdPartyMutation) SetThirdPartyUserAvatar(s string) {
	m.third_party_user_avatar = &s
}

// ThirdPartyUserAvatar returns the value of the "third_party_user_avatar" field in the mutation.
func (m *AppUserThirdPartyMutation) ThirdPartyUserAvatar() (r string, exists bool) {
	v := m.third_party_user_avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldThirdPartyUserAvatar returns the old "third_party_user_avatar" field's value of the AppUserThirdParty entity.
// If the AppUserThirdParty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserThirdPartyMutation) OldThirdPartyUserAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThirdPartyUserAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThirdPartyUserAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThirdPartyUserAvatar: %w", err)
	}
	return oldValue.ThirdPartyUserAvatar, nil
}

// ResetThirdPartyUserAvatar resets all changes to the "third_party_user_avatar" field.
func (m *AppUserThirdPartyMutation) ResetThirdPartyUserAvatar() {
	m.third_party_user_avatar = nil
}

// Where appends a list predicates to the AppUserThirdPartyMutation builder.
func (m *AppUserThirdPartyMutation) Where(ps ...predicate.AppUserThirdParty) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AppUserThirdPartyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AppUserThirdParty).
func (m *AppUserThirdPartyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppUserThirdPartyMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, appuserthirdparty.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appuserthirdparty.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, appuserthirdparty.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, appuserthirdparty.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, appuserthirdparty.FieldUserID)
	}
	if m.third_party_user_id != nil {
		fields = append(fields, appuserthirdparty.FieldThirdPartyUserID)
	}
	if m.third_party_id != nil {
		fields = append(fields, appuserthirdparty.FieldThirdPartyID)
	}
	if m.third_party_username != nil {
		fields = append(fields, appuserthirdparty.FieldThirdPartyUsername)
	}
	if m.third_party_user_avatar != nil {
		fields = append(fields, appuserthirdparty.FieldThirdPartyUserAvatar)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppUserThirdPartyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appuserthirdparty.FieldCreatedAt:
		return m.CreatedAt()
	case appuserthirdparty.FieldUpdatedAt:
		return m.UpdatedAt()
	case appuserthirdparty.FieldDeletedAt:
		return m.DeletedAt()
	case appuserthirdparty.FieldAppID:
		return m.AppID()
	case appuserthirdparty.FieldUserID:
		return m.UserID()
	case appuserthirdparty.FieldThirdPartyUserID:
		return m.ThirdPartyUserID()
	case appuserthirdparty.FieldThirdPartyID:
		return m.ThirdPartyID()
	case appuserthirdparty.FieldThirdPartyUsername:
		return m.ThirdPartyUsername()
	case appuserthirdparty.FieldThirdPartyUserAvatar:
		return m.ThirdPartyUserAvatar()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppUserThirdPartyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appuserthirdparty.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appuserthirdparty.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appuserthirdparty.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case appuserthirdparty.FieldAppID:
		return m.OldAppID(ctx)
	case appuserthirdparty.FieldUserID:
		return m.OldUserID(ctx)
	case appuserthirdparty.FieldThirdPartyUserID:
		return m.OldThirdPartyUserID(ctx)
	case appuserthirdparty.FieldThirdPartyID:
		return m.OldThirdPartyID(ctx)
	case appuserthirdparty.FieldThirdPartyUsername:
		return m.OldThirdPartyUsername(ctx)
	case appuserthirdparty.FieldThirdPartyUserAvatar:
		return m.OldThirdPartyUserAvatar(ctx)
	}
	return nil, fmt.Errorf("unknown AppUserThirdParty field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppUserThirdPartyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appuserthirdparty.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appuserthirdparty.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appuserthirdparty.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case appuserthirdparty.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appuserthirdparty.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case appuserthirdparty.FieldThirdPartyUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThirdPartyUserID(v)
		return nil
	case appuserthirdparty.FieldThirdPartyID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThirdPartyID(v)
		return nil
	case appuserthirdparty.FieldThirdPartyUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThirdPartyUsername(v)
		return nil
	case appuserthirdparty.FieldThirdPartyUserAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThirdPartyUserAvatar(v)
		return nil
	}
	return fmt.Errorf("unknown AppUserThirdParty field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppUserThirdPartyMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, appuserthirdparty.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, appuserthirdparty.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, appuserthirdparty.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppUserThirdPartyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appuserthirdparty.FieldCreatedAt:
		return m.AddedCreatedAt()
	case appuserthirdparty.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case appuserthirdparty.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppUserThirdPartyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appuserthirdparty.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case appuserthirdparty.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case appuserthirdparty.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppUserThirdParty numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppUserThirdPartyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppUserThirdPartyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppUserThirdPartyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AppUserThirdParty nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppUserThirdPartyMutation) ResetField(name string) error {
	switch name {
	case appuserthirdparty.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appuserthirdparty.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appuserthirdparty.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case appuserthirdparty.FieldAppID:
		m.ResetAppID()
		return nil
	case appuserthirdparty.FieldUserID:
		m.ResetUserID()
		return nil
	case appuserthirdparty.FieldThirdPartyUserID:
		m.ResetThirdPartyUserID()
		return nil
	case appuserthirdparty.FieldThirdPartyID:
		m.ResetThirdPartyID()
		return nil
	case appuserthirdparty.FieldThirdPartyUsername:
		m.ResetThirdPartyUsername()
		return nil
	case appuserthirdparty.FieldThirdPartyUserAvatar:
		m.ResetThirdPartyUserAvatar()
		return nil
	}
	return fmt.Errorf("unknown AppUserThirdParty field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppUserThirdPartyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppUserThirdPartyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppUserThirdPartyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppUserThirdPartyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppUserThirdPartyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppUserThirdPartyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppUserThirdPartyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppUserThirdParty unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppUserThirdPartyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppUserThirdParty edge %s", name)
}

// BanAppMutation represents an operation that mutates the BanApp nodes in the graph.
type BanAppMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	app_id        *uuid.UUID
	message       *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*BanApp, error)
	predicates    []predicate.BanApp
}

var _ ent.Mutation = (*BanAppMutation)(nil)

// banappOption allows management of the mutation configuration using functional options.
type banappOption func(*BanAppMutation)

// newBanAppMutation creates new mutation for the BanApp entity.
func newBanAppMutation(c config, op Op, opts ...banappOption) *BanAppMutation {
	m := &BanAppMutation{
		config:        c,
		op:            op,
		typ:           TypeBanApp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBanAppID sets the ID field of the mutation.
func withBanAppID(id uuid.UUID) banappOption {
	return func(m *BanAppMutation) {
		var (
			err   error
			once  sync.Once
			value *BanApp
		)
		m.oldValue = func(ctx context.Context) (*BanApp, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BanApp.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBanApp sets the old BanApp of the mutation.
func withBanApp(node *BanApp) banappOption {
	return func(m *BanAppMutation) {
		m.oldValue = func(context.Context) (*BanApp, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BanAppMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BanAppMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BanApp entities.
func (m *BanAppMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BanAppMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BanAppMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BanApp.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BanAppMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BanAppMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BanApp entity.
// If the BanApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanAppMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *BanAppMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *BanAppMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BanAppMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BanAppMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BanAppMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BanApp entity.
// If the BanApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanAppMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *BanAppMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *BanAppMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BanAppMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BanAppMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BanAppMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the BanApp entity.
// If the BanApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanAppMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *BanAppMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *BanAppMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BanAppMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *BanAppMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *BanAppMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the BanApp entity.
// If the BanApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanAppMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *BanAppMutation) ResetAppID() {
	m.app_id = nil
}

// SetMessage sets the "message" field.
func (m *BanAppMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *BanAppMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the BanApp entity.
// If the BanApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanAppMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *BanAppMutation) ResetMessage() {
	m.message = nil
}

// Where appends a list predicates to the BanAppMutation builder.
func (m *BanAppMutation) Where(ps ...predicate.BanApp) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BanAppMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (BanApp).
func (m *BanAppMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BanAppMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, banapp.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, banapp.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, banapp.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, banapp.FieldAppID)
	}
	if m.message != nil {
		fields = append(fields, banapp.FieldMessage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BanAppMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case banapp.FieldCreatedAt:
		return m.CreatedAt()
	case banapp.FieldUpdatedAt:
		return m.UpdatedAt()
	case banapp.FieldDeletedAt:
		return m.DeletedAt()
	case banapp.FieldAppID:
		return m.AppID()
	case banapp.FieldMessage:
		return m.Message()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BanAppMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case banapp.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case banapp.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case banapp.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case banapp.FieldAppID:
		return m.OldAppID(ctx)
	case banapp.FieldMessage:
		return m.OldMessage(ctx)
	}
	return nil, fmt.Errorf("unknown BanApp field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BanAppMutation) SetField(name string, value ent.Value) error {
	switch name {
	case banapp.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case banapp.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case banapp.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case banapp.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case banapp.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	}
	return fmt.Errorf("unknown BanApp field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BanAppMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, banapp.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, banapp.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, banapp.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BanAppMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case banapp.FieldCreatedAt:
		return m.AddedCreatedAt()
	case banapp.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case banapp.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BanAppMutation) AddField(name string, value ent.Value) error {
	switch name {
	case banapp.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case banapp.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case banapp.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BanApp numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BanAppMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BanAppMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BanAppMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BanApp nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BanAppMutation) ResetField(name string) error {
	switch name {
	case banapp.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case banapp.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case banapp.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case banapp.FieldAppID:
		m.ResetAppID()
		return nil
	case banapp.FieldMessage:
		m.ResetMessage()
		return nil
	}
	return fmt.Errorf("unknown BanApp field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BanAppMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BanAppMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BanAppMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BanAppMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BanAppMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BanAppMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BanAppMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BanApp unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BanAppMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BanApp edge %s", name)
}

// BanAppUserMutation represents an operation that mutates the BanAppUser nodes in the graph.
type BanAppUserMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	app_id        *uuid.UUID
	user_id       *uuid.UUID
	message       *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*BanAppUser, error)
	predicates    []predicate.BanAppUser
}

var _ ent.Mutation = (*BanAppUserMutation)(nil)

// banappuserOption allows management of the mutation configuration using functional options.
type banappuserOption func(*BanAppUserMutation)

// newBanAppUserMutation creates new mutation for the BanAppUser entity.
func newBanAppUserMutation(c config, op Op, opts ...banappuserOption) *BanAppUserMutation {
	m := &BanAppUserMutation{
		config:        c,
		op:            op,
		typ:           TypeBanAppUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBanAppUserID sets the ID field of the mutation.
func withBanAppUserID(id uuid.UUID) banappuserOption {
	return func(m *BanAppUserMutation) {
		var (
			err   error
			once  sync.Once
			value *BanAppUser
		)
		m.oldValue = func(ctx context.Context) (*BanAppUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BanAppUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBanAppUser sets the old BanAppUser of the mutation.
func withBanAppUser(node *BanAppUser) banappuserOption {
	return func(m *BanAppUserMutation) {
		m.oldValue = func(context.Context) (*BanAppUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BanAppUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BanAppUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BanAppUser entities.
func (m *BanAppUserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BanAppUserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BanAppUserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BanAppUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BanAppUserMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BanAppUserMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BanAppUser entity.
// If the BanAppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanAppUserMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *BanAppUserMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *BanAppUserMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BanAppUserMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BanAppUserMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BanAppUserMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BanAppUser entity.
// If the BanAppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanAppUserMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *BanAppUserMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *BanAppUserMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BanAppUserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BanAppUserMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BanAppUserMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the BanAppUser entity.
// If the BanAppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanAppUserMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *BanAppUserMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *BanAppUserMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BanAppUserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetAppID sets the "app_id" field.
func (m *BanAppUserMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *BanAppUserMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the BanAppUser entity.
// If the BanAppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanAppUserMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *BanAppUserMutation) ResetAppID() {
	m.app_id = nil
}

// SetUserID sets the "user_id" field.
func (m *BanAppUserMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *BanAppUserMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the BanAppUser entity.
// If the BanAppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanAppUserMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *BanAppUserMutation) ResetUserID() {
	m.user_id = nil
}

// SetMessage sets the "message" field.
func (m *BanAppUserMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *BanAppUserMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the BanAppUser entity.
// If the BanAppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BanAppUserMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *BanAppUserMutation) ResetMessage() {
	m.message = nil
}

// Where appends a list predicates to the BanAppUserMutation builder.
func (m *BanAppUserMutation) Where(ps ...predicate.BanAppUser) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BanAppUserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (BanAppUser).
func (m *BanAppUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BanAppUserMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, banappuser.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, banappuser.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, banappuser.FieldDeletedAt)
	}
	if m.app_id != nil {
		fields = append(fields, banappuser.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, banappuser.FieldUserID)
	}
	if m.message != nil {
		fields = append(fields, banappuser.FieldMessage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BanAppUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case banappuser.FieldCreatedAt:
		return m.CreatedAt()
	case banappuser.FieldUpdatedAt:
		return m.UpdatedAt()
	case banappuser.FieldDeletedAt:
		return m.DeletedAt()
	case banappuser.FieldAppID:
		return m.AppID()
	case banappuser.FieldUserID:
		return m.UserID()
	case banappuser.FieldMessage:
		return m.Message()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BanAppUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case banappuser.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case banappuser.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case banappuser.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case banappuser.FieldAppID:
		return m.OldAppID(ctx)
	case banappuser.FieldUserID:
		return m.OldUserID(ctx)
	case banappuser.FieldMessage:
		return m.OldMessage(ctx)
	}
	return nil, fmt.Errorf("unknown BanAppUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BanAppUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case banappuser.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case banappuser.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case banappuser.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case banappuser.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case banappuser.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case banappuser.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	}
	return fmt.Errorf("unknown BanAppUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BanAppUserMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, banappuser.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, banappuser.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, banappuser.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BanAppUserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case banappuser.FieldCreatedAt:
		return m.AddedCreatedAt()
	case banappuser.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case banappuser.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BanAppUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case banappuser.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case banappuser.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case banappuser.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BanAppUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BanAppUserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BanAppUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BanAppUserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BanAppUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BanAppUserMutation) ResetField(name string) error {
	switch name {
	case banappuser.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case banappuser.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case banappuser.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case banappuser.FieldAppID:
		m.ResetAppID()
		return nil
	case banappuser.FieldUserID:
		m.ResetUserID()
		return nil
	case banappuser.FieldMessage:
		m.ResetMessage()
		return nil
	}
	return fmt.Errorf("unknown BanAppUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BanAppUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BanAppUserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BanAppUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BanAppUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BanAppUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BanAppUserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BanAppUserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BanAppUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BanAppUserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BanAppUser edge %s", name)
}
